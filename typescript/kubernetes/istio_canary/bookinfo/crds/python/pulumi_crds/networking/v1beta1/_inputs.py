# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities

__all__ = [
    'DestinationRuleSpecArgs',
    'DestinationRuleSpecSubsetsArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyOutlierDetectionArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetectionArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPortArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsArgs',
    'DestinationRuleSpecSubsetsTrafficPolicyTlsArgs',
    'DestinationRuleSpecTrafficPolicyArgs',
    'DestinationRuleSpecTrafficPolicyConnectionPoolArgs',
    'DestinationRuleSpecTrafficPolicyConnectionPoolHttpArgs',
    'DestinationRuleSpecTrafficPolicyConnectionPoolTcpArgs',
    'DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs',
    'DestinationRuleSpecTrafficPolicyOutlierDetectionArgs',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsArgs',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolArgs',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetectionArgs',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsPortArgs',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsArgs',
    'DestinationRuleSpecTrafficPolicyTlsArgs',
    'GatewaySpecArgs',
    'GatewaySpecServersArgs',
    'GatewaySpecServersPortArgs',
    'GatewaySpecServersTlsArgs',
    'ProxyConfigSpecArgs',
    'ProxyConfigSpecImageArgs',
    'ProxyConfigSpecSelectorArgs',
    'ServiceEntrySpecArgs',
    'ServiceEntrySpecEndpointsArgs',
    'ServiceEntrySpecPortsArgs',
    'ServiceEntrySpecWorkloadSelectorArgs',
    'SidecarSpecArgs',
    'SidecarSpecEgressArgs',
    'SidecarSpecEgressPortArgs',
    'SidecarSpecIngressArgs',
    'SidecarSpecIngressPortArgs',
    'SidecarSpecOutboundTrafficPolicyArgs',
    'SidecarSpecOutboundTrafficPolicyEgressProxyArgs',
    'SidecarSpecOutboundTrafficPolicyEgressProxyPortArgs',
    'SidecarSpecWorkloadSelectorArgs',
    'VirtualServiceSpecArgs',
    'VirtualServiceSpecHttpArgs',
    'VirtualServiceSpecHttpCorsPolicyArgs',
    'VirtualServiceSpecHttpDelegateArgs',
    'VirtualServiceSpecHttpFaultArgs',
    'VirtualServiceSpecHttpHeadersArgs',
    'VirtualServiceSpecHttpHeadersRequestArgs',
    'VirtualServiceSpecHttpHeadersResponseArgs',
    'VirtualServiceSpecHttpMatchArgs',
    'VirtualServiceSpecHttpMirrorArgs',
    'VirtualServiceSpecHttpMirrorPercentageArgs',
    'VirtualServiceSpecHttpMirrorPortArgs',
    'VirtualServiceSpecHttpRetriesArgs',
    'VirtualServiceSpecHttpRewriteArgs',
    'VirtualServiceSpecHttpRouteArgs',
    'VirtualServiceSpecHttpRouteDestinationArgs',
    'VirtualServiceSpecHttpRouteDestinationPortArgs',
    'VirtualServiceSpecHttpRouteHeadersArgs',
    'VirtualServiceSpecHttpRouteHeadersRequestArgs',
    'VirtualServiceSpecHttpRouteHeadersResponseArgs',
    'VirtualServiceSpecTcpArgs',
    'VirtualServiceSpecTcpMatchArgs',
    'VirtualServiceSpecTcpRouteArgs',
    'VirtualServiceSpecTcpRouteDestinationArgs',
    'VirtualServiceSpecTcpRouteDestinationPortArgs',
    'VirtualServiceSpecTlsArgs',
    'VirtualServiceSpecTlsMatchArgs',
    'VirtualServiceSpecTlsRouteArgs',
    'VirtualServiceSpecTlsRouteDestinationArgs',
    'VirtualServiceSpecTlsRouteDestinationPortArgs',
    'WorkloadEntrySpecArgs',
]

@pulumi.input_type
class DestinationRuleSpecArgs:
    def __init__(__self__, *,
                 export_to: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 subsets: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationRuleSpecSubsetsArgs']]]] = None,
                 traffic_policy: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyArgs']] = None):
        """
        Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
        :param pulumi.Input[Sequence[pulumi.Input[str]]] export_to: A list of namespaces to which this destination rule is exported.
        :param pulumi.Input[str] host: The name of a service from the service registry.
        """
        if export_to is not None:
            pulumi.set(__self__, "export_to", export_to)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if subsets is not None:
            pulumi.set(__self__, "subsets", subsets)
        if traffic_policy is not None:
            pulumi.set(__self__, "traffic_policy", traffic_policy)

    @property
    @pulumi.getter(name="exportTo")
    def export_to(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of namespaces to which this destination rule is exported.
        """
        return pulumi.get(self, "export_to")

    @export_to.setter
    def export_to(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "export_to", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def subsets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DestinationRuleSpecSubsetsArgs']]]]:
        return pulumi.get(self, "subsets")

    @subsets.setter
    def subsets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationRuleSpecSubsetsArgs']]]]):
        pulumi.set(self, "subsets", value)

    @property
    @pulumi.getter(name="trafficPolicy")
    def traffic_policy(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyArgs']]:
        return pulumi.get(self, "traffic_policy")

    @traffic_policy.setter
    def traffic_policy(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyArgs']]):
        pulumi.set(self, "traffic_policy", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 traffic_policy: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the subset.
        :param pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyArgs'] traffic_policy: Traffic policies that apply to this subset.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if traffic_policy is not None:
            pulumi.set(__self__, "traffic_policy", traffic_policy)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the subset.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="trafficPolicy")
    def traffic_policy(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyArgs']]:
        """
        Traffic policies that apply to this subset.
        """
        return pulumi.get(self, "traffic_policy")

    @traffic_policy.setter
    def traffic_policy(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyArgs']]):
        pulumi.set(self, "traffic_policy", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyArgs:
    def __init__(__self__, *,
                 connection_pool: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolArgs']] = None,
                 load_balancer: Optional[Any] = None,
                 outlier_detection: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyOutlierDetectionArgs']] = None,
                 port_level_settings: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsArgs']]]] = None,
                 tls: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyTlsArgs']] = None):
        """
        Traffic policies that apply to this subset.
        :param Any load_balancer: Settings controlling the load balancer algorithms.
        :param pulumi.Input[Sequence[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsArgs']]] port_level_settings: Traffic policies specific to individual ports.
        :param pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyTlsArgs'] tls: TLS related settings for connections to the upstream service.
        """
        if connection_pool is not None:
            pulumi.set(__self__, "connection_pool", connection_pool)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if outlier_detection is not None:
            pulumi.set(__self__, "outlier_detection", outlier_detection)
        if port_level_settings is not None:
            pulumi.set(__self__, "port_level_settings", port_level_settings)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolArgs']]:
        return pulumi.get(self, "connection_pool")

    @connection_pool.setter
    def connection_pool(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolArgs']]):
        pulumi.set(self, "connection_pool", value)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[Any]:
        """
        Settings controlling the load balancer algorithms.
        """
        return pulumi.get(self, "load_balancer")

    @load_balancer.setter
    def load_balancer(self, value: Optional[Any]):
        pulumi.set(self, "load_balancer", value)

    @property
    @pulumi.getter(name="outlierDetection")
    def outlier_detection(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyOutlierDetectionArgs']]:
        return pulumi.get(self, "outlier_detection")

    @outlier_detection.setter
    def outlier_detection(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyOutlierDetectionArgs']]):
        pulumi.set(self, "outlier_detection", value)

    @property
    @pulumi.getter(name="portLevelSettings")
    def port_level_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsArgs']]]]:
        """
        Traffic policies specific to individual ports.
        """
        return pulumi.get(self, "port_level_settings")

    @port_level_settings.setter
    def port_level_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsArgs']]]]):
        pulumi.set(self, "port_level_settings", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyTlsArgs']]:
        """
        TLS related settings for connections to the upstream service.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyTlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpArgs']] = None,
                 tcp: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpArgs']] = None):
        """
        :param pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpArgs'] http: HTTP connection pool settings.
        :param pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpArgs'] tcp: Settings common to both HTTP and TCP upstream connections.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpArgs']]:
        """
        HTTP connection pool settings.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpArgs']]:
        """
        Settings common to both HTTP and TCP upstream connections.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpArgs']]):
        pulumi.set(self, "tcp", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpArgs:
    def __init__(__self__, *,
                 h2_upgrade_policy: Optional[pulumi.Input[str]] = None,
                 http1_max_pending_requests: Optional[pulumi.Input[int]] = None,
                 http2_max_requests: Optional[pulumi.Input[int]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None,
                 max_requests_per_connection: Optional[pulumi.Input[int]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 use_client_protocol: Optional[pulumi.Input[bool]] = None):
        """
        HTTP connection pool settings.
        :param pulumi.Input[str] h2_upgrade_policy: Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        :param pulumi.Input[int] http1_max_pending_requests: Maximum number of pending HTTP requests to a destination.
        :param pulumi.Input[int] http2_max_requests: Maximum number of requests to a backend.
        :param pulumi.Input[str] idle_timeout: The idle timeout for upstream connection pool connections.
        :param pulumi.Input[int] max_requests_per_connection: Maximum number of requests per connection to a backend.
        :param pulumi.Input[bool] use_client_protocol: If set to true, client protocol will be preserved while initiating connection to backend.
        """
        if h2_upgrade_policy is not None:
            pulumi.set(__self__, "h2_upgrade_policy", h2_upgrade_policy)
        if http1_max_pending_requests is not None:
            pulumi.set(__self__, "http1_max_pending_requests", http1_max_pending_requests)
        if http2_max_requests is not None:
            pulumi.set(__self__, "http2_max_requests", http2_max_requests)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if use_client_protocol is not None:
            pulumi.set(__self__, "use_client_protocol", use_client_protocol)

    @property
    @pulumi.getter(name="h2UpgradePolicy")
    def h2_upgrade_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        """
        return pulumi.get(self, "h2_upgrade_policy")

    @h2_upgrade_policy.setter
    def h2_upgrade_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "h2_upgrade_policy", value)

    @property
    @pulumi.getter(name="http1MaxPendingRequests")
    def http1_max_pending_requests(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of pending HTTP requests to a destination.
        """
        return pulumi.get(self, "http1_max_pending_requests")

    @http1_max_pending_requests.setter
    def http1_max_pending_requests(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http1_max_pending_requests", value)

    @property
    @pulumi.getter(name="http2MaxRequests")
    def http2_max_requests(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of requests to a backend.
        """
        return pulumi.get(self, "http2_max_requests")

    @http2_max_requests.setter
    def http2_max_requests(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http2_max_requests", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The idle timeout for upstream connection pool connections.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of requests per connection to a backend.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @max_requests_per_connection.setter
    def max_requests_per_connection(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_requests_per_connection", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="useClientProtocol")
    def use_client_protocol(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, client protocol will be preserved while initiating connection to backend.
        """
        return pulumi.get(self, "use_client_protocol")

    @use_client_protocol.setter
    def use_client_protocol(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_client_protocol", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpArgs:
    def __init__(__self__, *,
                 connect_timeout: Optional[pulumi.Input[str]] = None,
                 max_connections: Optional[pulumi.Input[int]] = None,
                 tcp_keepalive: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs']] = None):
        """
        Settings common to both HTTP and TCP upstream connections.
        :param pulumi.Input[str] connect_timeout: TCP connection timeout.
        :param pulumi.Input[int] max_connections: Maximum number of HTTP1 /TCP connections to a destination host.
        :param pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs'] tcp_keepalive: If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if tcp_keepalive is not None:
            pulumi.set(__self__, "tcp_keepalive", tcp_keepalive)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        TCP connection timeout.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of HTTP1 /TCP connections to a destination host.
        """
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="tcpKeepalive")
    def tcp_keepalive(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs']]:
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        return pulumi.get(self, "tcp_keepalive")

    @tcp_keepalive.setter
    def tcp_keepalive(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs']]):
        pulumi.set(self, "tcp_keepalive", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[str]] = None,
                 probes: Optional[pulumi.Input[int]] = None,
                 time: Optional[pulumi.Input[str]] = None):
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        :param pulumi.Input[str] interval: The time duration between keep-alive probes.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        The time duration between keep-alive probes.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def probes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "probes")

    @probes.setter
    def probes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "probes", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyOutlierDetectionArgs:
    def __init__(__self__, *,
                 base_ejection_time: Optional[pulumi.Input[str]] = None,
                 consecutive5xx_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_gateway_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_local_origin_failures: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[str]] = None,
                 max_ejection_percent: Optional[pulumi.Input[int]] = None,
                 min_health_percent: Optional[pulumi.Input[int]] = None,
                 split_external_local_origin_errors: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] base_ejection_time: Minimum ejection duration.
        :param pulumi.Input[int] consecutive5xx_errors: Number of 5xx errors before a host is ejected from the connection pool.
        :param pulumi.Input[int] consecutive_gateway_errors: Number of gateway errors before a host is ejected from the connection pool.
        :param pulumi.Input[str] interval: Time interval between ejection sweep analysis.
        :param pulumi.Input[bool] split_external_local_origin_errors: Determines whether to distinguish local origin failures from external errors.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive5xx_errors is not None:
            pulumi.set(__self__, "consecutive5xx_errors", consecutive5xx_errors)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_errors is not None:
            pulumi.set(__self__, "consecutive_gateway_errors", consecutive_gateway_errors)
        if consecutive_local_origin_failures is not None:
            pulumi.set(__self__, "consecutive_local_origin_failures", consecutive_local_origin_failures)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if min_health_percent is not None:
            pulumi.set(__self__, "min_health_percent", min_health_percent)
        if split_external_local_origin_errors is not None:
            pulumi.set(__self__, "split_external_local_origin_errors", split_external_local_origin_errors)

    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum ejection duration.
        """
        return pulumi.get(self, "base_ejection_time")

    @base_ejection_time.setter
    def base_ejection_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_ejection_time", value)

    @property
    @pulumi.getter(name="consecutive5xxErrors")
    def consecutive5xx_errors(self) -> Optional[pulumi.Input[int]]:
        """
        Number of 5xx errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive5xx_errors")

    @consecutive5xx_errors.setter
    def consecutive5xx_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive5xx_errors", value)

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "consecutive_errors")

    @consecutive_errors.setter
    def consecutive_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_errors", value)

    @property
    @pulumi.getter(name="consecutiveGatewayErrors")
    def consecutive_gateway_errors(self) -> Optional[pulumi.Input[int]]:
        """
        Number of gateway errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive_gateway_errors")

    @consecutive_gateway_errors.setter
    def consecutive_gateway_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_gateway_errors", value)

    @property
    @pulumi.getter(name="consecutiveLocalOriginFailures")
    def consecutive_local_origin_failures(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "consecutive_local_origin_failures")

    @consecutive_local_origin_failures.setter
    def consecutive_local_origin_failures(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_local_origin_failures", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        Time interval between ejection sweep analysis.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_ejection_percent")

    @max_ejection_percent.setter
    def max_ejection_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_ejection_percent", value)

    @property
    @pulumi.getter(name="minHealthPercent")
    def min_health_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_health_percent")

    @min_health_percent.setter
    def min_health_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_health_percent", value)

    @property
    @pulumi.getter(name="splitExternalLocalOriginErrors")
    def split_external_local_origin_errors(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to distinguish local origin failures from external errors.
        """
        return pulumi.get(self, "split_external_local_origin_errors")

    @split_external_local_origin_errors.setter
    def split_external_local_origin_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "split_external_local_origin_errors", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsArgs:
    def __init__(__self__, *,
                 connection_pool: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolArgs']] = None,
                 load_balancer: Optional[Any] = None,
                 outlier_detection: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetectionArgs']] = None,
                 port: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPortArgs']] = None,
                 tls: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsArgs']] = None):
        """
        :param Any load_balancer: Settings controlling the load balancer algorithms.
        :param pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsArgs'] tls: TLS related settings for connections to the upstream service.
        """
        if connection_pool is not None:
            pulumi.set(__self__, "connection_pool", connection_pool)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if outlier_detection is not None:
            pulumi.set(__self__, "outlier_detection", outlier_detection)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolArgs']]:
        return pulumi.get(self, "connection_pool")

    @connection_pool.setter
    def connection_pool(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolArgs']]):
        pulumi.set(self, "connection_pool", value)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[Any]:
        """
        Settings controlling the load balancer algorithms.
        """
        return pulumi.get(self, "load_balancer")

    @load_balancer.setter
    def load_balancer(self, value: Optional[Any]):
        pulumi.set(self, "load_balancer", value)

    @property
    @pulumi.getter(name="outlierDetection")
    def outlier_detection(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetectionArgs']]:
        return pulumi.get(self, "outlier_detection")

    @outlier_detection.setter
    def outlier_detection(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetectionArgs']]):
        pulumi.set(self, "outlier_detection", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPortArgs']]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPortArgs']]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsArgs']]:
        """
        TLS related settings for connections to the upstream service.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs']] = None,
                 tcp: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs']] = None):
        """
        :param pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs'] http: HTTP connection pool settings.
        :param pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs'] tcp: Settings common to both HTTP and TCP upstream connections.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs']]:
        """
        HTTP connection pool settings.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs']]:
        """
        Settings common to both HTTP and TCP upstream connections.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs']]):
        pulumi.set(self, "tcp", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs:
    def __init__(__self__, *,
                 h2_upgrade_policy: Optional[pulumi.Input[str]] = None,
                 http1_max_pending_requests: Optional[pulumi.Input[int]] = None,
                 http2_max_requests: Optional[pulumi.Input[int]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None,
                 max_requests_per_connection: Optional[pulumi.Input[int]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 use_client_protocol: Optional[pulumi.Input[bool]] = None):
        """
        HTTP connection pool settings.
        :param pulumi.Input[str] h2_upgrade_policy: Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        :param pulumi.Input[int] http1_max_pending_requests: Maximum number of pending HTTP requests to a destination.
        :param pulumi.Input[int] http2_max_requests: Maximum number of requests to a backend.
        :param pulumi.Input[str] idle_timeout: The idle timeout for upstream connection pool connections.
        :param pulumi.Input[int] max_requests_per_connection: Maximum number of requests per connection to a backend.
        :param pulumi.Input[bool] use_client_protocol: If set to true, client protocol will be preserved while initiating connection to backend.
        """
        if h2_upgrade_policy is not None:
            pulumi.set(__self__, "h2_upgrade_policy", h2_upgrade_policy)
        if http1_max_pending_requests is not None:
            pulumi.set(__self__, "http1_max_pending_requests", http1_max_pending_requests)
        if http2_max_requests is not None:
            pulumi.set(__self__, "http2_max_requests", http2_max_requests)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if use_client_protocol is not None:
            pulumi.set(__self__, "use_client_protocol", use_client_protocol)

    @property
    @pulumi.getter(name="h2UpgradePolicy")
    def h2_upgrade_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        """
        return pulumi.get(self, "h2_upgrade_policy")

    @h2_upgrade_policy.setter
    def h2_upgrade_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "h2_upgrade_policy", value)

    @property
    @pulumi.getter(name="http1MaxPendingRequests")
    def http1_max_pending_requests(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of pending HTTP requests to a destination.
        """
        return pulumi.get(self, "http1_max_pending_requests")

    @http1_max_pending_requests.setter
    def http1_max_pending_requests(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http1_max_pending_requests", value)

    @property
    @pulumi.getter(name="http2MaxRequests")
    def http2_max_requests(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of requests to a backend.
        """
        return pulumi.get(self, "http2_max_requests")

    @http2_max_requests.setter
    def http2_max_requests(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http2_max_requests", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The idle timeout for upstream connection pool connections.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of requests per connection to a backend.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @max_requests_per_connection.setter
    def max_requests_per_connection(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_requests_per_connection", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="useClientProtocol")
    def use_client_protocol(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, client protocol will be preserved while initiating connection to backend.
        """
        return pulumi.get(self, "use_client_protocol")

    @use_client_protocol.setter
    def use_client_protocol(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_client_protocol", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs:
    def __init__(__self__, *,
                 connect_timeout: Optional[pulumi.Input[str]] = None,
                 max_connections: Optional[pulumi.Input[int]] = None,
                 tcp_keepalive: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs']] = None):
        """
        Settings common to both HTTP and TCP upstream connections.
        :param pulumi.Input[str] connect_timeout: TCP connection timeout.
        :param pulumi.Input[int] max_connections: Maximum number of HTTP1 /TCP connections to a destination host.
        :param pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs'] tcp_keepalive: If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if tcp_keepalive is not None:
            pulumi.set(__self__, "tcp_keepalive", tcp_keepalive)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        TCP connection timeout.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of HTTP1 /TCP connections to a destination host.
        """
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="tcpKeepalive")
    def tcp_keepalive(self) -> Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs']]:
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        return pulumi.get(self, "tcp_keepalive")

    @tcp_keepalive.setter
    def tcp_keepalive(self, value: Optional[pulumi.Input['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs']]):
        pulumi.set(self, "tcp_keepalive", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[str]] = None,
                 probes: Optional[pulumi.Input[int]] = None,
                 time: Optional[pulumi.Input[str]] = None):
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        :param pulumi.Input[str] interval: The time duration between keep-alive probes.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        The time duration between keep-alive probes.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def probes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "probes")

    @probes.setter
    def probes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "probes", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetectionArgs:
    def __init__(__self__, *,
                 base_ejection_time: Optional[pulumi.Input[str]] = None,
                 consecutive5xx_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_gateway_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_local_origin_failures: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[str]] = None,
                 max_ejection_percent: Optional[pulumi.Input[int]] = None,
                 min_health_percent: Optional[pulumi.Input[int]] = None,
                 split_external_local_origin_errors: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] base_ejection_time: Minimum ejection duration.
        :param pulumi.Input[int] consecutive5xx_errors: Number of 5xx errors before a host is ejected from the connection pool.
        :param pulumi.Input[int] consecutive_gateway_errors: Number of gateway errors before a host is ejected from the connection pool.
        :param pulumi.Input[str] interval: Time interval between ejection sweep analysis.
        :param pulumi.Input[bool] split_external_local_origin_errors: Determines whether to distinguish local origin failures from external errors.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive5xx_errors is not None:
            pulumi.set(__self__, "consecutive5xx_errors", consecutive5xx_errors)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_errors is not None:
            pulumi.set(__self__, "consecutive_gateway_errors", consecutive_gateway_errors)
        if consecutive_local_origin_failures is not None:
            pulumi.set(__self__, "consecutive_local_origin_failures", consecutive_local_origin_failures)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if min_health_percent is not None:
            pulumi.set(__self__, "min_health_percent", min_health_percent)
        if split_external_local_origin_errors is not None:
            pulumi.set(__self__, "split_external_local_origin_errors", split_external_local_origin_errors)

    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum ejection duration.
        """
        return pulumi.get(self, "base_ejection_time")

    @base_ejection_time.setter
    def base_ejection_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_ejection_time", value)

    @property
    @pulumi.getter(name="consecutive5xxErrors")
    def consecutive5xx_errors(self) -> Optional[pulumi.Input[int]]:
        """
        Number of 5xx errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive5xx_errors")

    @consecutive5xx_errors.setter
    def consecutive5xx_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive5xx_errors", value)

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "consecutive_errors")

    @consecutive_errors.setter
    def consecutive_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_errors", value)

    @property
    @pulumi.getter(name="consecutiveGatewayErrors")
    def consecutive_gateway_errors(self) -> Optional[pulumi.Input[int]]:
        """
        Number of gateway errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive_gateway_errors")

    @consecutive_gateway_errors.setter
    def consecutive_gateway_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_gateway_errors", value)

    @property
    @pulumi.getter(name="consecutiveLocalOriginFailures")
    def consecutive_local_origin_failures(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "consecutive_local_origin_failures")

    @consecutive_local_origin_failures.setter
    def consecutive_local_origin_failures(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_local_origin_failures", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        Time interval between ejection sweep analysis.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_ejection_percent")

    @max_ejection_percent.setter
    def max_ejection_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_ejection_percent", value)

    @property
    @pulumi.getter(name="minHealthPercent")
    def min_health_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_health_percent")

    @min_health_percent.setter
    def min_health_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_health_percent", value)

    @property
    @pulumi.getter(name="splitExternalLocalOriginErrors")
    def split_external_local_origin_errors(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to distinguish local origin failures from external errors.
        """
        return pulumi.get(self, "split_external_local_origin_errors")

    @split_external_local_origin_errors.setter
    def split_external_local_origin_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "split_external_local_origin_errors", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPortArgs:
    def __init__(__self__, *,
                 number: Optional[pulumi.Input[int]] = None):
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsArgs:
    def __init__(__self__, *,
                 ca_certificates: Optional[pulumi.Input[str]] = None,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 credential_name: Optional[pulumi.Input[str]] = None,
                 insecure_skip_verify: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 sni: Optional[pulumi.Input[str]] = None,
                 subject_alt_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        TLS related settings for connections to the upstream service.
        :param pulumi.Input[str] client_certificate: REQUIRED if mode is `MUTUAL`.
        :param pulumi.Input[str] private_key: REQUIRED if mode is `MUTUAL`.
        :param pulumi.Input[str] sni: SNI string to present to the server during TLS handshake.
        """
        if ca_certificates is not None:
            pulumi.set(__self__, "ca_certificates", ca_certificates)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter(name="caCertificates")
    def ca_certificates(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_certificates")

    @ca_certificates.setter
    def ca_certificates(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificates", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_name")

    @credential_name.setter
    def credential_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_name", value)

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input[str]]:
        """
        SNI string to present to the server during TLS handshake.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "subject_alt_names")

    @subject_alt_names.setter
    def subject_alt_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subject_alt_names", value)


@pulumi.input_type
class DestinationRuleSpecSubsetsTrafficPolicyTlsArgs:
    def __init__(__self__, *,
                 ca_certificates: Optional[pulumi.Input[str]] = None,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 credential_name: Optional[pulumi.Input[str]] = None,
                 insecure_skip_verify: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 sni: Optional[pulumi.Input[str]] = None,
                 subject_alt_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        TLS related settings for connections to the upstream service.
        :param pulumi.Input[str] client_certificate: REQUIRED if mode is `MUTUAL`.
        :param pulumi.Input[str] private_key: REQUIRED if mode is `MUTUAL`.
        :param pulumi.Input[str] sni: SNI string to present to the server during TLS handshake.
        """
        if ca_certificates is not None:
            pulumi.set(__self__, "ca_certificates", ca_certificates)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter(name="caCertificates")
    def ca_certificates(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_certificates")

    @ca_certificates.setter
    def ca_certificates(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificates", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_name")

    @credential_name.setter
    def credential_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_name", value)

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input[str]]:
        """
        SNI string to present to the server during TLS handshake.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "subject_alt_names")

    @subject_alt_names.setter
    def subject_alt_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subject_alt_names", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyArgs:
    def __init__(__self__, *,
                 connection_pool: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolArgs']] = None,
                 load_balancer: Optional[Any] = None,
                 outlier_detection: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyOutlierDetectionArgs']] = None,
                 port_level_settings: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsArgs']]]] = None,
                 tls: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyTlsArgs']] = None):
        """
        :param Any load_balancer: Settings controlling the load balancer algorithms.
        :param pulumi.Input[Sequence[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsArgs']]] port_level_settings: Traffic policies specific to individual ports.
        :param pulumi.Input['DestinationRuleSpecTrafficPolicyTlsArgs'] tls: TLS related settings for connections to the upstream service.
        """
        if connection_pool is not None:
            pulumi.set(__self__, "connection_pool", connection_pool)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if outlier_detection is not None:
            pulumi.set(__self__, "outlier_detection", outlier_detection)
        if port_level_settings is not None:
            pulumi.set(__self__, "port_level_settings", port_level_settings)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolArgs']]:
        return pulumi.get(self, "connection_pool")

    @connection_pool.setter
    def connection_pool(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolArgs']]):
        pulumi.set(self, "connection_pool", value)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[Any]:
        """
        Settings controlling the load balancer algorithms.
        """
        return pulumi.get(self, "load_balancer")

    @load_balancer.setter
    def load_balancer(self, value: Optional[Any]):
        pulumi.set(self, "load_balancer", value)

    @property
    @pulumi.getter(name="outlierDetection")
    def outlier_detection(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyOutlierDetectionArgs']]:
        return pulumi.get(self, "outlier_detection")

    @outlier_detection.setter
    def outlier_detection(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyOutlierDetectionArgs']]):
        pulumi.set(self, "outlier_detection", value)

    @property
    @pulumi.getter(name="portLevelSettings")
    def port_level_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsArgs']]]]:
        """
        Traffic policies specific to individual ports.
        """
        return pulumi.get(self, "port_level_settings")

    @port_level_settings.setter
    def port_level_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsArgs']]]]):
        pulumi.set(self, "port_level_settings", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyTlsArgs']]:
        """
        TLS related settings for connections to the upstream service.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyTlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyConnectionPoolArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolHttpArgs']] = None,
                 tcp: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolTcpArgs']] = None):
        """
        :param pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolHttpArgs'] http: HTTP connection pool settings.
        :param pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolTcpArgs'] tcp: Settings common to both HTTP and TCP upstream connections.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolHttpArgs']]:
        """
        HTTP connection pool settings.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolTcpArgs']]:
        """
        Settings common to both HTTP and TCP upstream connections.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolTcpArgs']]):
        pulumi.set(self, "tcp", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyConnectionPoolHttpArgs:
    def __init__(__self__, *,
                 h2_upgrade_policy: Optional[pulumi.Input[str]] = None,
                 http1_max_pending_requests: Optional[pulumi.Input[int]] = None,
                 http2_max_requests: Optional[pulumi.Input[int]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None,
                 max_requests_per_connection: Optional[pulumi.Input[int]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 use_client_protocol: Optional[pulumi.Input[bool]] = None):
        """
        HTTP connection pool settings.
        :param pulumi.Input[str] h2_upgrade_policy: Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        :param pulumi.Input[int] http1_max_pending_requests: Maximum number of pending HTTP requests to a destination.
        :param pulumi.Input[int] http2_max_requests: Maximum number of requests to a backend.
        :param pulumi.Input[str] idle_timeout: The idle timeout for upstream connection pool connections.
        :param pulumi.Input[int] max_requests_per_connection: Maximum number of requests per connection to a backend.
        :param pulumi.Input[bool] use_client_protocol: If set to true, client protocol will be preserved while initiating connection to backend.
        """
        if h2_upgrade_policy is not None:
            pulumi.set(__self__, "h2_upgrade_policy", h2_upgrade_policy)
        if http1_max_pending_requests is not None:
            pulumi.set(__self__, "http1_max_pending_requests", http1_max_pending_requests)
        if http2_max_requests is not None:
            pulumi.set(__self__, "http2_max_requests", http2_max_requests)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if use_client_protocol is not None:
            pulumi.set(__self__, "use_client_protocol", use_client_protocol)

    @property
    @pulumi.getter(name="h2UpgradePolicy")
    def h2_upgrade_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        """
        return pulumi.get(self, "h2_upgrade_policy")

    @h2_upgrade_policy.setter
    def h2_upgrade_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "h2_upgrade_policy", value)

    @property
    @pulumi.getter(name="http1MaxPendingRequests")
    def http1_max_pending_requests(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of pending HTTP requests to a destination.
        """
        return pulumi.get(self, "http1_max_pending_requests")

    @http1_max_pending_requests.setter
    def http1_max_pending_requests(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http1_max_pending_requests", value)

    @property
    @pulumi.getter(name="http2MaxRequests")
    def http2_max_requests(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of requests to a backend.
        """
        return pulumi.get(self, "http2_max_requests")

    @http2_max_requests.setter
    def http2_max_requests(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http2_max_requests", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The idle timeout for upstream connection pool connections.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of requests per connection to a backend.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @max_requests_per_connection.setter
    def max_requests_per_connection(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_requests_per_connection", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="useClientProtocol")
    def use_client_protocol(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, client protocol will be preserved while initiating connection to backend.
        """
        return pulumi.get(self, "use_client_protocol")

    @use_client_protocol.setter
    def use_client_protocol(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_client_protocol", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyConnectionPoolTcpArgs:
    def __init__(__self__, *,
                 connect_timeout: Optional[pulumi.Input[str]] = None,
                 max_connections: Optional[pulumi.Input[int]] = None,
                 tcp_keepalive: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs']] = None):
        """
        Settings common to both HTTP and TCP upstream connections.
        :param pulumi.Input[str] connect_timeout: TCP connection timeout.
        :param pulumi.Input[int] max_connections: Maximum number of HTTP1 /TCP connections to a destination host.
        :param pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs'] tcp_keepalive: If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if tcp_keepalive is not None:
            pulumi.set(__self__, "tcp_keepalive", tcp_keepalive)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        TCP connection timeout.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of HTTP1 /TCP connections to a destination host.
        """
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="tcpKeepalive")
    def tcp_keepalive(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs']]:
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        return pulumi.get(self, "tcp_keepalive")

    @tcp_keepalive.setter
    def tcp_keepalive(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs']]):
        pulumi.set(self, "tcp_keepalive", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[str]] = None,
                 probes: Optional[pulumi.Input[int]] = None,
                 time: Optional[pulumi.Input[str]] = None):
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        :param pulumi.Input[str] interval: The time duration between keep-alive probes.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        The time duration between keep-alive probes.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def probes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "probes")

    @probes.setter
    def probes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "probes", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyOutlierDetectionArgs:
    def __init__(__self__, *,
                 base_ejection_time: Optional[pulumi.Input[str]] = None,
                 consecutive5xx_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_gateway_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_local_origin_failures: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[str]] = None,
                 max_ejection_percent: Optional[pulumi.Input[int]] = None,
                 min_health_percent: Optional[pulumi.Input[int]] = None,
                 split_external_local_origin_errors: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] base_ejection_time: Minimum ejection duration.
        :param pulumi.Input[int] consecutive5xx_errors: Number of 5xx errors before a host is ejected from the connection pool.
        :param pulumi.Input[int] consecutive_gateway_errors: Number of gateway errors before a host is ejected from the connection pool.
        :param pulumi.Input[str] interval: Time interval between ejection sweep analysis.
        :param pulumi.Input[bool] split_external_local_origin_errors: Determines whether to distinguish local origin failures from external errors.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive5xx_errors is not None:
            pulumi.set(__self__, "consecutive5xx_errors", consecutive5xx_errors)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_errors is not None:
            pulumi.set(__self__, "consecutive_gateway_errors", consecutive_gateway_errors)
        if consecutive_local_origin_failures is not None:
            pulumi.set(__self__, "consecutive_local_origin_failures", consecutive_local_origin_failures)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if min_health_percent is not None:
            pulumi.set(__self__, "min_health_percent", min_health_percent)
        if split_external_local_origin_errors is not None:
            pulumi.set(__self__, "split_external_local_origin_errors", split_external_local_origin_errors)

    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum ejection duration.
        """
        return pulumi.get(self, "base_ejection_time")

    @base_ejection_time.setter
    def base_ejection_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_ejection_time", value)

    @property
    @pulumi.getter(name="consecutive5xxErrors")
    def consecutive5xx_errors(self) -> Optional[pulumi.Input[int]]:
        """
        Number of 5xx errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive5xx_errors")

    @consecutive5xx_errors.setter
    def consecutive5xx_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive5xx_errors", value)

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "consecutive_errors")

    @consecutive_errors.setter
    def consecutive_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_errors", value)

    @property
    @pulumi.getter(name="consecutiveGatewayErrors")
    def consecutive_gateway_errors(self) -> Optional[pulumi.Input[int]]:
        """
        Number of gateway errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive_gateway_errors")

    @consecutive_gateway_errors.setter
    def consecutive_gateway_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_gateway_errors", value)

    @property
    @pulumi.getter(name="consecutiveLocalOriginFailures")
    def consecutive_local_origin_failures(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "consecutive_local_origin_failures")

    @consecutive_local_origin_failures.setter
    def consecutive_local_origin_failures(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_local_origin_failures", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        Time interval between ejection sweep analysis.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_ejection_percent")

    @max_ejection_percent.setter
    def max_ejection_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_ejection_percent", value)

    @property
    @pulumi.getter(name="minHealthPercent")
    def min_health_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_health_percent")

    @min_health_percent.setter
    def min_health_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_health_percent", value)

    @property
    @pulumi.getter(name="splitExternalLocalOriginErrors")
    def split_external_local_origin_errors(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to distinguish local origin failures from external errors.
        """
        return pulumi.get(self, "split_external_local_origin_errors")

    @split_external_local_origin_errors.setter
    def split_external_local_origin_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "split_external_local_origin_errors", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsArgs:
    def __init__(__self__, *,
                 connection_pool: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolArgs']] = None,
                 load_balancer: Optional[Any] = None,
                 outlier_detection: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetectionArgs']] = None,
                 port: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsPortArgs']] = None,
                 tls: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsArgs']] = None):
        """
        :param Any load_balancer: Settings controlling the load balancer algorithms.
        :param pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsArgs'] tls: TLS related settings for connections to the upstream service.
        """
        if connection_pool is not None:
            pulumi.set(__self__, "connection_pool", connection_pool)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if outlier_detection is not None:
            pulumi.set(__self__, "outlier_detection", outlier_detection)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolArgs']]:
        return pulumi.get(self, "connection_pool")

    @connection_pool.setter
    def connection_pool(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolArgs']]):
        pulumi.set(self, "connection_pool", value)

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[Any]:
        """
        Settings controlling the load balancer algorithms.
        """
        return pulumi.get(self, "load_balancer")

    @load_balancer.setter
    def load_balancer(self, value: Optional[Any]):
        pulumi.set(self, "load_balancer", value)

    @property
    @pulumi.getter(name="outlierDetection")
    def outlier_detection(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetectionArgs']]:
        return pulumi.get(self, "outlier_detection")

    @outlier_detection.setter
    def outlier_detection(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetectionArgs']]):
        pulumi.set(self, "outlier_detection", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsPortArgs']]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsPortArgs']]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsArgs']]:
        """
        TLS related settings for connections to the upstream service.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolArgs:
    def __init__(__self__, *,
                 http: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs']] = None,
                 tcp: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs']] = None):
        """
        :param pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs'] http: HTTP connection pool settings.
        :param pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs'] tcp: Settings common to both HTTP and TCP upstream connections.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs']]:
        """
        HTTP connection pool settings.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs']]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs']]:
        """
        Settings common to both HTTP and TCP upstream connections.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs']]):
        pulumi.set(self, "tcp", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs:
    def __init__(__self__, *,
                 h2_upgrade_policy: Optional[pulumi.Input[str]] = None,
                 http1_max_pending_requests: Optional[pulumi.Input[int]] = None,
                 http2_max_requests: Optional[pulumi.Input[int]] = None,
                 idle_timeout: Optional[pulumi.Input[str]] = None,
                 max_requests_per_connection: Optional[pulumi.Input[int]] = None,
                 max_retries: Optional[pulumi.Input[int]] = None,
                 use_client_protocol: Optional[pulumi.Input[bool]] = None):
        """
        HTTP connection pool settings.
        :param pulumi.Input[str] h2_upgrade_policy: Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        :param pulumi.Input[int] http1_max_pending_requests: Maximum number of pending HTTP requests to a destination.
        :param pulumi.Input[int] http2_max_requests: Maximum number of requests to a backend.
        :param pulumi.Input[str] idle_timeout: The idle timeout for upstream connection pool connections.
        :param pulumi.Input[int] max_requests_per_connection: Maximum number of requests per connection to a backend.
        :param pulumi.Input[bool] use_client_protocol: If set to true, client protocol will be preserved while initiating connection to backend.
        """
        if h2_upgrade_policy is not None:
            pulumi.set(__self__, "h2_upgrade_policy", h2_upgrade_policy)
        if http1_max_pending_requests is not None:
            pulumi.set(__self__, "http1_max_pending_requests", http1_max_pending_requests)
        if http2_max_requests is not None:
            pulumi.set(__self__, "http2_max_requests", http2_max_requests)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if use_client_protocol is not None:
            pulumi.set(__self__, "use_client_protocol", use_client_protocol)

    @property
    @pulumi.getter(name="h2UpgradePolicy")
    def h2_upgrade_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        """
        return pulumi.get(self, "h2_upgrade_policy")

    @h2_upgrade_policy.setter
    def h2_upgrade_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "h2_upgrade_policy", value)

    @property
    @pulumi.getter(name="http1MaxPendingRequests")
    def http1_max_pending_requests(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of pending HTTP requests to a destination.
        """
        return pulumi.get(self, "http1_max_pending_requests")

    @http1_max_pending_requests.setter
    def http1_max_pending_requests(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http1_max_pending_requests", value)

    @property
    @pulumi.getter(name="http2MaxRequests")
    def http2_max_requests(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of requests to a backend.
        """
        return pulumi.get(self, "http2_max_requests")

    @http2_max_requests.setter
    def http2_max_requests(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http2_max_requests", value)

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        The idle timeout for upstream connection pool connections.
        """
        return pulumi.get(self, "idle_timeout")

    @idle_timeout.setter
    def idle_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "idle_timeout", value)

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of requests per connection to a backend.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @max_requests_per_connection.setter
    def max_requests_per_connection(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_requests_per_connection", value)

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_retries")

    @max_retries.setter
    def max_retries(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_retries", value)

    @property
    @pulumi.getter(name="useClientProtocol")
    def use_client_protocol(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, client protocol will be preserved while initiating connection to backend.
        """
        return pulumi.get(self, "use_client_protocol")

    @use_client_protocol.setter
    def use_client_protocol(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_client_protocol", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs:
    def __init__(__self__, *,
                 connect_timeout: Optional[pulumi.Input[str]] = None,
                 max_connections: Optional[pulumi.Input[int]] = None,
                 tcp_keepalive: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs']] = None):
        """
        Settings common to both HTTP and TCP upstream connections.
        :param pulumi.Input[str] connect_timeout: TCP connection timeout.
        :param pulumi.Input[int] max_connections: Maximum number of HTTP1 /TCP connections to a destination host.
        :param pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs'] tcp_keepalive: If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if tcp_keepalive is not None:
            pulumi.set(__self__, "tcp_keepalive", tcp_keepalive)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        TCP connection timeout.
        """
        return pulumi.get(self, "connect_timeout")

    @connect_timeout.setter
    def connect_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connect_timeout", value)

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of HTTP1 /TCP connections to a destination host.
        """
        return pulumi.get(self, "max_connections")

    @max_connections.setter
    def max_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_connections", value)

    @property
    @pulumi.getter(name="tcpKeepalive")
    def tcp_keepalive(self) -> Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs']]:
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        return pulumi.get(self, "tcp_keepalive")

    @tcp_keepalive.setter
    def tcp_keepalive(self, value: Optional[pulumi.Input['DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs']]):
        pulumi.set(self, "tcp_keepalive", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[str]] = None,
                 probes: Optional[pulumi.Input[int]] = None,
                 time: Optional[pulumi.Input[str]] = None):
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        :param pulumi.Input[str] interval: The time duration between keep-alive probes.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        The time duration between keep-alive probes.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def probes(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "probes")

    @probes.setter
    def probes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "probes", value)

    @property
    @pulumi.getter
    def time(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time")

    @time.setter
    def time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetectionArgs:
    def __init__(__self__, *,
                 base_ejection_time: Optional[pulumi.Input[str]] = None,
                 consecutive5xx_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_gateway_errors: Optional[pulumi.Input[int]] = None,
                 consecutive_local_origin_failures: Optional[pulumi.Input[int]] = None,
                 interval: Optional[pulumi.Input[str]] = None,
                 max_ejection_percent: Optional[pulumi.Input[int]] = None,
                 min_health_percent: Optional[pulumi.Input[int]] = None,
                 split_external_local_origin_errors: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] base_ejection_time: Minimum ejection duration.
        :param pulumi.Input[int] consecutive5xx_errors: Number of 5xx errors before a host is ejected from the connection pool.
        :param pulumi.Input[int] consecutive_gateway_errors: Number of gateway errors before a host is ejected from the connection pool.
        :param pulumi.Input[str] interval: Time interval between ejection sweep analysis.
        :param pulumi.Input[bool] split_external_local_origin_errors: Determines whether to distinguish local origin failures from external errors.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive5xx_errors is not None:
            pulumi.set(__self__, "consecutive5xx_errors", consecutive5xx_errors)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_errors is not None:
            pulumi.set(__self__, "consecutive_gateway_errors", consecutive_gateway_errors)
        if consecutive_local_origin_failures is not None:
            pulumi.set(__self__, "consecutive_local_origin_failures", consecutive_local_origin_failures)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if min_health_percent is not None:
            pulumi.set(__self__, "min_health_percent", min_health_percent)
        if split_external_local_origin_errors is not None:
            pulumi.set(__self__, "split_external_local_origin_errors", split_external_local_origin_errors)

    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional[pulumi.Input[str]]:
        """
        Minimum ejection duration.
        """
        return pulumi.get(self, "base_ejection_time")

    @base_ejection_time.setter
    def base_ejection_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "base_ejection_time", value)

    @property
    @pulumi.getter(name="consecutive5xxErrors")
    def consecutive5xx_errors(self) -> Optional[pulumi.Input[int]]:
        """
        Number of 5xx errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive5xx_errors")

    @consecutive5xx_errors.setter
    def consecutive5xx_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive5xx_errors", value)

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "consecutive_errors")

    @consecutive_errors.setter
    def consecutive_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_errors", value)

    @property
    @pulumi.getter(name="consecutiveGatewayErrors")
    def consecutive_gateway_errors(self) -> Optional[pulumi.Input[int]]:
        """
        Number of gateway errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive_gateway_errors")

    @consecutive_gateway_errors.setter
    def consecutive_gateway_errors(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_gateway_errors", value)

    @property
    @pulumi.getter(name="consecutiveLocalOriginFailures")
    def consecutive_local_origin_failures(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "consecutive_local_origin_failures")

    @consecutive_local_origin_failures.setter
    def consecutive_local_origin_failures(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive_local_origin_failures", value)

    @property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[str]]:
        """
        Time interval between ejection sweep analysis.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_ejection_percent")

    @max_ejection_percent.setter
    def max_ejection_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_ejection_percent", value)

    @property
    @pulumi.getter(name="minHealthPercent")
    def min_health_percent(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_health_percent")

    @min_health_percent.setter
    def min_health_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_health_percent", value)

    @property
    @pulumi.getter(name="splitExternalLocalOriginErrors")
    def split_external_local_origin_errors(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to distinguish local origin failures from external errors.
        """
        return pulumi.get(self, "split_external_local_origin_errors")

    @split_external_local_origin_errors.setter
    def split_external_local_origin_errors(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "split_external_local_origin_errors", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsPortArgs:
    def __init__(__self__, *,
                 number: Optional[pulumi.Input[int]] = None):
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsArgs:
    def __init__(__self__, *,
                 ca_certificates: Optional[pulumi.Input[str]] = None,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 credential_name: Optional[pulumi.Input[str]] = None,
                 insecure_skip_verify: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 sni: Optional[pulumi.Input[str]] = None,
                 subject_alt_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        TLS related settings for connections to the upstream service.
        :param pulumi.Input[str] client_certificate: REQUIRED if mode is `MUTUAL`.
        :param pulumi.Input[str] private_key: REQUIRED if mode is `MUTUAL`.
        :param pulumi.Input[str] sni: SNI string to present to the server during TLS handshake.
        """
        if ca_certificates is not None:
            pulumi.set(__self__, "ca_certificates", ca_certificates)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter(name="caCertificates")
    def ca_certificates(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_certificates")

    @ca_certificates.setter
    def ca_certificates(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificates", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_name")

    @credential_name.setter
    def credential_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_name", value)

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input[str]]:
        """
        SNI string to present to the server during TLS handshake.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "subject_alt_names")

    @subject_alt_names.setter
    def subject_alt_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subject_alt_names", value)


@pulumi.input_type
class DestinationRuleSpecTrafficPolicyTlsArgs:
    def __init__(__self__, *,
                 ca_certificates: Optional[pulumi.Input[str]] = None,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 credential_name: Optional[pulumi.Input[str]] = None,
                 insecure_skip_verify: Optional[pulumi.Input[bool]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 sni: Optional[pulumi.Input[str]] = None,
                 subject_alt_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        TLS related settings for connections to the upstream service.
        :param pulumi.Input[str] client_certificate: REQUIRED if mode is `MUTUAL`.
        :param pulumi.Input[str] private_key: REQUIRED if mode is `MUTUAL`.
        :param pulumi.Input[str] sni: SNI string to present to the server during TLS handshake.
        """
        if ca_certificates is not None:
            pulumi.set(__self__, "ca_certificates", ca_certificates)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter(name="caCertificates")
    def ca_certificates(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "ca_certificates")

    @ca_certificates.setter
    def ca_certificates(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificates", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_name")

    @credential_name.setter
    def credential_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_name", value)

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "insecure_skip_verify")

    @insecure_skip_verify.setter
    def insecure_skip_verify(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "insecure_skip_verify", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter
    def sni(self) -> Optional[pulumi.Input[str]]:
        """
        SNI string to present to the server during TLS handshake.
        """
        return pulumi.get(self, "sni")

    @sni.setter
    def sni(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sni", value)

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "subject_alt_names")

    @subject_alt_names.setter
    def subject_alt_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subject_alt_names", value)


@pulumi.input_type
class GatewaySpecArgs:
    def __init__(__self__, *,
                 selector: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 servers: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecServersArgs']]]] = None):
        """
        Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
        :param pulumi.Input[Sequence[pulumi.Input['GatewaySpecServersArgs']]] servers: A list of server specifications.
        """
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "selector", value)

    @property
    @pulumi.getter
    def servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecServersArgs']]]]:
        """
        A list of server specifications.
        """
        return pulumi.get(self, "servers")

    @servers.setter
    def servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GatewaySpecServersArgs']]]]):
        pulumi.set(self, "servers", value)


@pulumi.input_type
class GatewaySpecServersArgs:
    def __init__(__self__, *,
                 bind: Optional[pulumi.Input[str]] = None,
                 default_endpoint: Optional[pulumi.Input[str]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input['GatewaySpecServersPortArgs']] = None,
                 tls: Optional[pulumi.Input['GatewaySpecServersTlsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: One or more hosts exposed by this gateway.
        :param pulumi.Input[str] name: An optional name of the server, when set must be unique across all servers.
        :param pulumi.Input['GatewaySpecServersTlsArgs'] tls: Set of TLS related options that govern the server's behavior.
        """
        if bind is not None:
            pulumi.set(__self__, "bind", bind)
        if default_endpoint is not None:
            pulumi.set(__self__, "default_endpoint", default_endpoint)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def bind(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bind")

    @bind.setter
    def bind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bind", value)

    @property
    @pulumi.getter(name="defaultEndpoint")
    def default_endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_endpoint")

    @default_endpoint.setter
    def default_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_endpoint", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        One or more hosts exposed by this gateway.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        An optional name of the server, when set must be unique across all servers.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['GatewaySpecServersPortArgs']]:
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['GatewaySpecServersPortArgs']]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input['GatewaySpecServersTlsArgs']]:
        """
        Set of TLS related options that govern the server's behavior.
        """
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input['GatewaySpecServersTlsArgs']]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class GatewaySpecServersPortArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 number: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 target_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: Label assigned to the port.
        :param pulumi.Input[int] number: A valid non-negative integer port number.
        :param pulumi.Input[str] protocol: The protocol exposed on the port.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Label assigned to the port.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        """
        A valid non-negative integer port number.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol exposed on the port.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_port", value)


@pulumi.input_type
class GatewaySpecServersTlsArgs:
    def __init__(__self__, *,
                 ca_certificates: Optional[pulumi.Input[str]] = None,
                 cipher_suites: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 credential_name: Optional[pulumi.Input[str]] = None,
                 https_redirect: Optional[pulumi.Input[bool]] = None,
                 max_protocol_version: Optional[pulumi.Input[str]] = None,
                 min_protocol_version: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 server_certificate: Optional[pulumi.Input[str]] = None,
                 subject_alt_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verify_certificate_hash: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verify_certificate_spki: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        Set of TLS related options that govern the server's behavior.
        :param pulumi.Input[str] ca_certificates: REQUIRED if mode is `MUTUAL`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] cipher_suites: Optional: If specified, only support the specified cipher list.
        :param pulumi.Input[str] max_protocol_version: Optional: Maximum TLS protocol version.
        :param pulumi.Input[str] min_protocol_version: Optional: Minimum TLS protocol version.
        :param pulumi.Input[str] private_key: REQUIRED if mode is `SIMPLE` or `MUTUAL`.
        :param pulumi.Input[str] server_certificate: REQUIRED if mode is `SIMPLE` or `MUTUAL`.
        """
        if ca_certificates is not None:
            pulumi.set(__self__, "ca_certificates", ca_certificates)
        if cipher_suites is not None:
            pulumi.set(__self__, "cipher_suites", cipher_suites)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if max_protocol_version is not None:
            pulumi.set(__self__, "max_protocol_version", max_protocol_version)
        if min_protocol_version is not None:
            pulumi.set(__self__, "min_protocol_version", min_protocol_version)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if server_certificate is not None:
            pulumi.set(__self__, "server_certificate", server_certificate)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)
        if verify_certificate_hash is not None:
            pulumi.set(__self__, "verify_certificate_hash", verify_certificate_hash)
        if verify_certificate_spki is not None:
            pulumi.set(__self__, "verify_certificate_spki", verify_certificate_spki)

    @property
    @pulumi.getter(name="caCertificates")
    def ca_certificates(self) -> Optional[pulumi.Input[str]]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "ca_certificates")

    @ca_certificates.setter
    def ca_certificates(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificates", value)

    @property
    @pulumi.getter(name="cipherSuites")
    def cipher_suites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Optional: If specified, only support the specified cipher list.
        """
        return pulumi.get(self, "cipher_suites")

    @cipher_suites.setter
    def cipher_suites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "cipher_suites", value)

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "credential_name")

    @credential_name.setter
    def credential_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "credential_name", value)

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "https_redirect")

    @https_redirect.setter
    def https_redirect(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "https_redirect", value)

    @property
    @pulumi.getter(name="maxProtocolVersion")
    def max_protocol_version(self) -> Optional[pulumi.Input[str]]:
        """
        Optional: Maximum TLS protocol version.
        """
        return pulumi.get(self, "max_protocol_version")

    @max_protocol_version.setter
    def max_protocol_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_protocol_version", value)

    @property
    @pulumi.getter(name="minProtocolVersion")
    def min_protocol_version(self) -> Optional[pulumi.Input[str]]:
        """
        Optional: Minimum TLS protocol version.
        """
        return pulumi.get(self, "min_protocol_version")

    @min_protocol_version.setter
    def min_protocol_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_protocol_version", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        REQUIRED if mode is `SIMPLE` or `MUTUAL`.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="serverCertificate")
    def server_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        REQUIRED if mode is `SIMPLE` or `MUTUAL`.
        """
        return pulumi.get(self, "server_certificate")

    @server_certificate.setter
    def server_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "server_certificate", value)

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "subject_alt_names")

    @subject_alt_names.setter
    def subject_alt_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subject_alt_names", value)

    @property
    @pulumi.getter(name="verifyCertificateHash")
    def verify_certificate_hash(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "verify_certificate_hash")

    @verify_certificate_hash.setter
    def verify_certificate_hash(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "verify_certificate_hash", value)

    @property
    @pulumi.getter(name="verifyCertificateSpki")
    def verify_certificate_spki(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "verify_certificate_spki")

    @verify_certificate_spki.setter
    def verify_certificate_spki(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "verify_certificate_spki", value)


@pulumi.input_type
class ProxyConfigSpecArgs:
    def __init__(__self__, *,
                 concurrency: Optional[pulumi.Input[int]] = None,
                 environment_variables: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 image: Optional[pulumi.Input['ProxyConfigSpecImageArgs']] = None,
                 selector: Optional[pulumi.Input['ProxyConfigSpecSelectorArgs']] = None):
        """
        Provides configuration for individual workloads. See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
        :param pulumi.Input[int] concurrency: The number of worker threads to run.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] environment_variables: Additional environment variables for the proxy.
        :param pulumi.Input['ProxyConfigSpecImageArgs'] image: Specifies the details of the proxy image.
        :param pulumi.Input['ProxyConfigSpecSelectorArgs'] selector: Optional.
        """
        if concurrency is not None:
            pulumi.set(__self__, "concurrency", concurrency)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def concurrency(self) -> Optional[pulumi.Input[int]]:
        """
        The number of worker threads to run.
        """
        return pulumi.get(self, "concurrency")

    @concurrency.setter
    def concurrency(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "concurrency", value)

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Additional environment variables for the proxy.
        """
        return pulumi.get(self, "environment_variables")

    @environment_variables.setter
    def environment_variables(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "environment_variables", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['ProxyConfigSpecImageArgs']]:
        """
        Specifies the details of the proxy image.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['ProxyConfigSpecImageArgs']]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def selector(self) -> Optional[pulumi.Input['ProxyConfigSpecSelectorArgs']]:
        """
        Optional.
        """
        return pulumi.get(self, "selector")

    @selector.setter
    def selector(self, value: Optional[pulumi.Input['ProxyConfigSpecSelectorArgs']]):
        pulumi.set(self, "selector", value)


@pulumi.input_type
class ProxyConfigSpecImageArgs:
    def __init__(__self__, *,
                 image_type: Optional[pulumi.Input[str]] = None):
        """
        Specifies the details of the proxy image.
        :param pulumi.Input[str] image_type: The image type of the image.
        """
        if image_type is not None:
            pulumi.set(__self__, "image_type", image_type)

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> Optional[pulumi.Input[str]]:
        """
        The image type of the image.
        """
        return pulumi.get(self, "image_type")

    @image_type.setter
    def image_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_type", value)


@pulumi.input_type
class ProxyConfigSpecSelectorArgs:
    def __init__(__self__, *,
                 match_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Optional.
        """
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "match_labels")

    @match_labels.setter
    def match_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "match_labels", value)


@pulumi.input_type
class ServiceEntrySpecArgs:
    def __init__(__self__, *,
                 addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 endpoints: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEntrySpecEndpointsArgs']]]] = None,
                 export_to: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 ports: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEntrySpecPortsArgs']]]] = None,
                 resolution: Optional[pulumi.Input[str]] = None,
                 subject_alt_names: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 workload_selector: Optional[pulumi.Input['ServiceEntrySpecWorkloadSelectorArgs']] = None):
        """
        Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: The virtual IP addresses associated with the service.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEntrySpecEndpointsArgs']]] endpoints: One or more endpoints associated with the service.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] export_to: A list of namespaces to which this service is exported.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: The hosts associated with the ServiceEntry.
        :param pulumi.Input[Sequence[pulumi.Input['ServiceEntrySpecPortsArgs']]] ports: The ports associated with the external service.
        :param pulumi.Input[str] resolution: Service discovery mode for the hosts.
        :param pulumi.Input['ServiceEntrySpecWorkloadSelectorArgs'] workload_selector: Applicable only for MESH_INTERNAL services.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if export_to is not None:
            pulumi.set(__self__, "export_to", export_to)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)
        if workload_selector is not None:
            pulumi.set(__self__, "workload_selector", workload_selector)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The virtual IP addresses associated with the service.
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEntrySpecEndpointsArgs']]]]:
        """
        One or more endpoints associated with the service.
        """
        return pulumi.get(self, "endpoints")

    @endpoints.setter
    def endpoints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEntrySpecEndpointsArgs']]]]):
        pulumi.set(self, "endpoints", value)

    @property
    @pulumi.getter(name="exportTo")
    def export_to(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of namespaces to which this service is exported.
        """
        return pulumi.get(self, "export_to")

    @export_to.setter
    def export_to(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "export_to", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The hosts associated with the ServiceEntry.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEntrySpecPortsArgs']]]]:
        """
        The ports associated with the external service.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServiceEntrySpecPortsArgs']]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter
    def resolution(self) -> Optional[pulumi.Input[str]]:
        """
        Service discovery mode for the hosts.
        """
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolution", value)

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "subject_alt_names")

    @subject_alt_names.setter
    def subject_alt_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "subject_alt_names", value)

    @property
    @pulumi.getter(name="workloadSelector")
    def workload_selector(self) -> Optional[pulumi.Input['ServiceEntrySpecWorkloadSelectorArgs']]:
        """
        Applicable only for MESH_INTERNAL services.
        """
        return pulumi.get(self, "workload_selector")

    @workload_selector.setter
    def workload_selector(self, value: Optional[pulumi.Input['ServiceEntrySpecWorkloadSelectorArgs']]):
        pulumi.set(self, "workload_selector", value)


@pulumi.input_type
class ServiceEntrySpecEndpointsArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 locality: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 ports: Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]] = None,
                 service_account: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: One or more labels associated with the endpoint.
        :param pulumi.Input[str] locality: The locality associated with the endpoint.
        :param pulumi.Input[Mapping[str, pulumi.Input[int]]] ports: Set of ports associated with the endpoint.
        :param pulumi.Input[int] weight: The load balancing weight associated with the endpoint.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        One or more labels associated with the endpoint.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def locality(self) -> Optional[pulumi.Input[str]]:
        """
        The locality associated with the endpoint.
        """
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locality", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]:
        """
        Set of ports associated with the endpoint.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        The load balancing weight associated with the endpoint.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class ServiceEntrySpecPortsArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 number: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 target_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] name: Label assigned to the port.
        :param pulumi.Input[int] number: A valid non-negative integer port number.
        :param pulumi.Input[str] protocol: The protocol exposed on the port.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Label assigned to the port.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        """
        A valid non-negative integer port number.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol exposed on the port.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_port", value)


@pulumi.input_type
class ServiceEntrySpecWorkloadSelectorArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        Applicable only for MESH_INTERNAL services.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class SidecarSpecArgs:
    def __init__(__self__, *,
                 egress: Optional[pulumi.Input[Sequence[pulumi.Input['SidecarSpecEgressArgs']]]] = None,
                 ingress: Optional[pulumi.Input[Sequence[pulumi.Input['SidecarSpecIngressArgs']]]] = None,
                 outbound_traffic_policy: Optional[pulumi.Input['SidecarSpecOutboundTrafficPolicyArgs']] = None,
                 workload_selector: Optional[pulumi.Input['SidecarSpecWorkloadSelectorArgs']] = None):
        """
        Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
        :param pulumi.Input['SidecarSpecOutboundTrafficPolicyArgs'] outbound_traffic_policy: Configuration for the outbound traffic policy.
        """
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if outbound_traffic_policy is not None:
            pulumi.set(__self__, "outbound_traffic_policy", outbound_traffic_policy)
        if workload_selector is not None:
            pulumi.set(__self__, "workload_selector", workload_selector)

    @property
    @pulumi.getter
    def egress(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SidecarSpecEgressArgs']]]]:
        return pulumi.get(self, "egress")

    @egress.setter
    def egress(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SidecarSpecEgressArgs']]]]):
        pulumi.set(self, "egress", value)

    @property
    @pulumi.getter
    def ingress(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SidecarSpecIngressArgs']]]]:
        return pulumi.get(self, "ingress")

    @ingress.setter
    def ingress(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SidecarSpecIngressArgs']]]]):
        pulumi.set(self, "ingress", value)

    @property
    @pulumi.getter(name="outboundTrafficPolicy")
    def outbound_traffic_policy(self) -> Optional[pulumi.Input['SidecarSpecOutboundTrafficPolicyArgs']]:
        """
        Configuration for the outbound traffic policy.
        """
        return pulumi.get(self, "outbound_traffic_policy")

    @outbound_traffic_policy.setter
    def outbound_traffic_policy(self, value: Optional[pulumi.Input['SidecarSpecOutboundTrafficPolicyArgs']]):
        pulumi.set(self, "outbound_traffic_policy", value)

    @property
    @pulumi.getter(name="workloadSelector")
    def workload_selector(self) -> Optional[pulumi.Input['SidecarSpecWorkloadSelectorArgs']]:
        return pulumi.get(self, "workload_selector")

    @workload_selector.setter
    def workload_selector(self, value: Optional[pulumi.Input['SidecarSpecWorkloadSelectorArgs']]):
        pulumi.set(self, "workload_selector", value)


@pulumi.input_type
class SidecarSpecEgressArgs:
    def __init__(__self__, *,
                 bind: Optional[pulumi.Input[str]] = None,
                 capture_mode: Optional[pulumi.Input[str]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input['SidecarSpecEgressPortArgs']] = None):
        """
        :param pulumi.Input['SidecarSpecEgressPortArgs'] port: The port associated with the listener.
        """
        if bind is not None:
            pulumi.set(__self__, "bind", bind)
        if capture_mode is not None:
            pulumi.set(__self__, "capture_mode", capture_mode)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def bind(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bind")

    @bind.setter
    def bind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bind", value)

    @property
    @pulumi.getter(name="captureMode")
    def capture_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "capture_mode")

    @capture_mode.setter
    def capture_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capture_mode", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['SidecarSpecEgressPortArgs']]:
        """
        The port associated with the listener.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['SidecarSpecEgressPortArgs']]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class SidecarSpecEgressPortArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 number: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 target_port: Optional[pulumi.Input[int]] = None):
        """
        The port associated with the listener.
        :param pulumi.Input[str] name: Label assigned to the port.
        :param pulumi.Input[int] number: A valid non-negative integer port number.
        :param pulumi.Input[str] protocol: The protocol exposed on the port.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Label assigned to the port.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        """
        A valid non-negative integer port number.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol exposed on the port.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_port", value)


@pulumi.input_type
class SidecarSpecIngressArgs:
    def __init__(__self__, *,
                 bind: Optional[pulumi.Input[str]] = None,
                 capture_mode: Optional[pulumi.Input[str]] = None,
                 default_endpoint: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input['SidecarSpecIngressPortArgs']] = None):
        """
        :param pulumi.Input[str] bind: The IP to which the listener should be bound.
        :param pulumi.Input['SidecarSpecIngressPortArgs'] port: The port associated with the listener.
        """
        if bind is not None:
            pulumi.set(__self__, "bind", bind)
        if capture_mode is not None:
            pulumi.set(__self__, "capture_mode", capture_mode)
        if default_endpoint is not None:
            pulumi.set(__self__, "default_endpoint", default_endpoint)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def bind(self) -> Optional[pulumi.Input[str]]:
        """
        The IP to which the listener should be bound.
        """
        return pulumi.get(self, "bind")

    @bind.setter
    def bind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bind", value)

    @property
    @pulumi.getter(name="captureMode")
    def capture_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "capture_mode")

    @capture_mode.setter
    def capture_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "capture_mode", value)

    @property
    @pulumi.getter(name="defaultEndpoint")
    def default_endpoint(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_endpoint")

    @default_endpoint.setter
    def default_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_endpoint", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['SidecarSpecIngressPortArgs']]:
        """
        The port associated with the listener.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['SidecarSpecIngressPortArgs']]):
        pulumi.set(self, "port", value)


@pulumi.input_type
class SidecarSpecIngressPortArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 number: Optional[pulumi.Input[int]] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 target_port: Optional[pulumi.Input[int]] = None):
        """
        The port associated with the listener.
        :param pulumi.Input[str] name: Label assigned to the port.
        :param pulumi.Input[int] number: A valid non-negative integer port number.
        :param pulumi.Input[str] protocol: The protocol exposed on the port.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Label assigned to the port.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        """
        A valid non-negative integer port number.
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        The protocol exposed on the port.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_port", value)


@pulumi.input_type
class SidecarSpecOutboundTrafficPolicyArgs:
    def __init__(__self__, *,
                 egress_proxy: Optional[pulumi.Input['SidecarSpecOutboundTrafficPolicyEgressProxyArgs']] = None,
                 mode: Optional[pulumi.Input[str]] = None):
        """
        Configuration for the outbound traffic policy.
        """
        if egress_proxy is not None:
            pulumi.set(__self__, "egress_proxy", egress_proxy)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="egressProxy")
    def egress_proxy(self) -> Optional[pulumi.Input['SidecarSpecOutboundTrafficPolicyEgressProxyArgs']]:
        return pulumi.get(self, "egress_proxy")

    @egress_proxy.setter
    def egress_proxy(self, value: Optional[pulumi.Input['SidecarSpecOutboundTrafficPolicyEgressProxyArgs']]):
        pulumi.set(self, "egress_proxy", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)


@pulumi.input_type
class SidecarSpecOutboundTrafficPolicyEgressProxyArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input['SidecarSpecOutboundTrafficPolicyEgressProxyPortArgs']] = None,
                 subset: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The name of a service from the service registry.
        :param pulumi.Input['SidecarSpecOutboundTrafficPolicyEgressProxyPortArgs'] port: Specifies the port on the host that is being addressed.
        :param pulumi.Input[str] subset: The name of a subset within the service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subset is not None:
            pulumi.set(__self__, "subset", subset)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['SidecarSpecOutboundTrafficPolicyEgressProxyPortArgs']]:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['SidecarSpecOutboundTrafficPolicyEgressProxyPortArgs']]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def subset(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a subset within the service.
        """
        return pulumi.get(self, "subset")

    @subset.setter
    def subset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subset", value)


@pulumi.input_type
class SidecarSpecOutboundTrafficPolicyEgressProxyPortArgs:
    def __init__(__self__, *,
                 number: Optional[pulumi.Input[int]] = None):
        """
        Specifies the port on the host that is being addressed.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)


@pulumi.input_type
class SidecarSpecWorkloadSelectorArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)


@pulumi.input_type
class VirtualServiceSpecArgs:
    def __init__(__self__, *,
                 export_to: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gateways: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 http: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecHttpArgs']]]] = None,
                 tcp: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTcpArgs']]]] = None,
                 tls: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTlsArgs']]]] = None):
        """
        Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
        :param pulumi.Input[Sequence[pulumi.Input[str]]] export_to: A list of namespaces to which this virtual service is exported.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gateways: The names of gateways and sidecars that should apply these routes.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] hosts: The destination hosts to which traffic is being sent.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecHttpArgs']]] http: An ordered list of route rules for HTTP traffic.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTcpArgs']]] tcp: An ordered list of route rules for opaque TCP traffic.
        """
        if export_to is not None:
            pulumi.set(__self__, "export_to", export_to)
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="exportTo")
    def export_to(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of namespaces to which this virtual service is exported.
        """
        return pulumi.get(self, "export_to")

    @export_to.setter
    def export_to(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "export_to", value)

    @property
    @pulumi.getter
    def gateways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The names of gateways and sidecars that should apply these routes.
        """
        return pulumi.get(self, "gateways")

    @gateways.setter
    def gateways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateways", value)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The destination hosts to which traffic is being sent.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "hosts", value)

    @property
    @pulumi.getter
    def http(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecHttpArgs']]]]:
        """
        An ordered list of route rules for HTTP traffic.
        """
        return pulumi.get(self, "http")

    @http.setter
    def http(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecHttpArgs']]]]):
        pulumi.set(self, "http", value)

    @property
    @pulumi.getter
    def tcp(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTcpArgs']]]]:
        """
        An ordered list of route rules for opaque TCP traffic.
        """
        return pulumi.get(self, "tcp")

    @tcp.setter
    def tcp(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTcpArgs']]]]):
        pulumi.set(self, "tcp", value)

    @property
    @pulumi.getter
    def tls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTlsArgs']]]]:
        return pulumi.get(self, "tls")

    @tls.setter
    def tls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTlsArgs']]]]):
        pulumi.set(self, "tls", value)


@pulumi.input_type
class VirtualServiceSpecHttpArgs:
    def __init__(__self__, *,
                 cors_policy: Optional[pulumi.Input['VirtualServiceSpecHttpCorsPolicyArgs']] = None,
                 delegate: Optional[pulumi.Input['VirtualServiceSpecHttpDelegateArgs']] = None,
                 fault: Optional[pulumi.Input['VirtualServiceSpecHttpFaultArgs']] = None,
                 headers: Optional[pulumi.Input['VirtualServiceSpecHttpHeadersArgs']] = None,
                 match: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecHttpMatchArgs']]]] = None,
                 mirror: Optional[pulumi.Input['VirtualServiceSpecHttpMirrorArgs']] = None,
                 mirror_percent: Optional[pulumi.Input[int]] = None,
                 mirror_percentage: Optional[pulumi.Input['VirtualServiceSpecHttpMirrorPercentageArgs']] = None,
                 mirror_percent: Optional[pulumi.Input[int]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 redirect: Optional[Any] = None,
                 retries: Optional[pulumi.Input['VirtualServiceSpecHttpRetriesArgs']] = None,
                 rewrite: Optional[pulumi.Input['VirtualServiceSpecHttpRewriteArgs']] = None,
                 route: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecHttpRouteArgs']]]] = None,
                 timeout: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['VirtualServiceSpecHttpCorsPolicyArgs'] cors_policy: Cross-Origin Resource Sharing policy (CORS).
        :param pulumi.Input['VirtualServiceSpecHttpFaultArgs'] fault: Fault injection policy to apply on HTTP traffic at the client side.
        :param pulumi.Input[int] mirror_percent: Percentage of the traffic to be mirrored by the `mirror` field.
        :param pulumi.Input['VirtualServiceSpecHttpMirrorPercentageArgs'] mirror_percentage: Percentage of the traffic to be mirrored by the `mirror` field.
        :param pulumi.Input[int] mirror_percent: Percentage of the traffic to be mirrored by the `mirror` field.
        :param pulumi.Input[str] name: The name assigned to the route for debugging purposes.
        :param Any redirect: A HTTP rule can either redirect or forward (default) traffic.
        :param pulumi.Input['VirtualServiceSpecHttpRetriesArgs'] retries: Retry policy for HTTP requests.
        :param pulumi.Input['VirtualServiceSpecHttpRewriteArgs'] rewrite: Rewrite HTTP URIs and Authority headers.
        :param pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecHttpRouteArgs']]] route: A HTTP rule can either redirect or forward (default) traffic.
        :param pulumi.Input[str] timeout: Timeout for HTTP requests, default is disabled.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if delegate is not None:
            pulumi.set(__self__, "delegate", delegate)
        if fault is not None:
            pulumi.set(__self__, "fault", fault)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if mirror is not None:
            pulumi.set(__self__, "mirror", mirror)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)
        if mirror_percentage is not None:
            pulumi.set(__self__, "mirror_percentage", mirror_percentage)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if rewrite is not None:
            pulumi.set(__self__, "rewrite", rewrite)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpCorsPolicyArgs']]:
        """
        Cross-Origin Resource Sharing policy (CORS).
        """
        return pulumi.get(self, "cors_policy")

    @cors_policy.setter
    def cors_policy(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpCorsPolicyArgs']]):
        pulumi.set(self, "cors_policy", value)

    @property
    @pulumi.getter
    def delegate(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpDelegateArgs']]:
        return pulumi.get(self, "delegate")

    @delegate.setter
    def delegate(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpDelegateArgs']]):
        pulumi.set(self, "delegate", value)

    @property
    @pulumi.getter
    def fault(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpFaultArgs']]:
        """
        Fault injection policy to apply on HTTP traffic at the client side.
        """
        return pulumi.get(self, "fault")

    @fault.setter
    def fault(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpFaultArgs']]):
        pulumi.set(self, "fault", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpHeadersArgs']]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecHttpMatchArgs']]]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecHttpMatchArgs']]]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def mirror(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpMirrorArgs']]:
        return pulumi.get(self, "mirror")

    @mirror.setter
    def mirror(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpMirrorArgs']]):
        pulumi.set(self, "mirror", value)

    @property
    @pulumi.getter(name="mirrorPercent")
    def mirror_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Percentage of the traffic to be mirrored by the `mirror` field.
        """
        return pulumi.get(self, "mirror_percent")

    @mirror_percent.setter
    def mirror_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mirror_percent", value)

    @property
    @pulumi.getter(name="mirrorPercentage")
    def mirror_percentage(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpMirrorPercentageArgs']]:
        """
        Percentage of the traffic to be mirrored by the `mirror` field.
        """
        return pulumi.get(self, "mirror_percentage")

    @mirror_percentage.setter
    def mirror_percentage(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpMirrorPercentageArgs']]):
        pulumi.set(self, "mirror_percentage", value)

    @property
    @pulumi.getter
    def mirror_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Percentage of the traffic to be mirrored by the `mirror` field.
        """
        return pulumi.get(self, "mirror_percent")

    @mirror_percent.setter
    def mirror_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "mirror_percent", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name assigned to the route for debugging purposes.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def redirect(self) -> Optional[Any]:
        """
        A HTTP rule can either redirect or forward (default) traffic.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[Any]):
        pulumi.set(self, "redirect", value)

    @property
    @pulumi.getter
    def retries(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpRetriesArgs']]:
        """
        Retry policy for HTTP requests.
        """
        return pulumi.get(self, "retries")

    @retries.setter
    def retries(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpRetriesArgs']]):
        pulumi.set(self, "retries", value)

    @property
    @pulumi.getter
    def rewrite(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpRewriteArgs']]:
        """
        Rewrite HTTP URIs and Authority headers.
        """
        return pulumi.get(self, "rewrite")

    @rewrite.setter
    def rewrite(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpRewriteArgs']]):
        pulumi.set(self, "rewrite", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecHttpRouteArgs']]]]:
        """
        A HTTP rule can either redirect or forward (default) traffic.
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecHttpRouteArgs']]]]):
        pulumi.set(self, "route", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout for HTTP requests, default is disabled.
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timeout", value)


@pulumi.input_type
class VirtualServiceSpecHttpCorsPolicyArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_origin: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_origins: Optional[pulumi.Input[Sequence[Any]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[str]] = None):
        """
        Cross-Origin Resource Sharing policy (CORS).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_methods: List of HTTP methods allowed to access the resource.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_origin: The list of origins that are allowed to perform CORS requests.
        :param pulumi.Input[Sequence[Any]] allow_origins: String patterns that match allowed origins.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin is not None:
            pulumi.set(__self__, "allow_origin", allow_origin)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_headers", value)

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of HTTP methods allowed to access the resource.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_methods", value)

    @property
    @pulumi.getter(name="allowOrigin")
    def allow_origin(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The list of origins that are allowed to perform CORS requests.
        """
        return pulumi.get(self, "allow_origin")

    @allow_origin.setter
    def allow_origin(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_origin", value)

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input[Sequence[Any]]]:
        """
        String patterns that match allowed origins.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input[Sequence[Any]]]):
        pulumi.set(self, "allow_origins", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_age", value)


@pulumi.input_type
class VirtualServiceSpecHttpDelegateArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 namespace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name specifies the name of the delegate VirtualService.
        :param pulumi.Input[str] namespace: Namespace specifies the namespace where the delegate VirtualService resides.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name specifies the name of the delegate VirtualService.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace specifies the namespace where the delegate VirtualService resides.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)


@pulumi.input_type
class VirtualServiceSpecHttpFaultArgs:
    def __init__(__self__, *,
                 abort: Optional[Any] = None,
                 delay: Optional[Any] = None):
        """
        Fault injection policy to apply on HTTP traffic at the client side.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @property
    @pulumi.getter
    def abort(self) -> Optional[Any]:
        return pulumi.get(self, "abort")

    @abort.setter
    def abort(self, value: Optional[Any]):
        pulumi.set(self, "abort", value)

    @property
    @pulumi.getter
    def delay(self) -> Optional[Any]:
        return pulumi.get(self, "delay")

    @delay.setter
    def delay(self, value: Optional[Any]):
        pulumi.set(self, "delay", value)


@pulumi.input_type
class VirtualServiceSpecHttpHeadersArgs:
    def __init__(__self__, *,
                 request: Optional[pulumi.Input['VirtualServiceSpecHttpHeadersRequestArgs']] = None,
                 response: Optional[pulumi.Input['VirtualServiceSpecHttpHeadersResponseArgs']] = None):
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpHeadersRequestArgs']]:
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpHeadersRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpHeadersResponseArgs']]:
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpHeadersResponseArgs']]):
        pulumi.set(self, "response", value)


@pulumi.input_type
class VirtualServiceSpecHttpHeadersRequestArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "set", value)


@pulumi.input_type
class VirtualServiceSpecHttpHeadersResponseArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "set", value)


@pulumi.input_type
class VirtualServiceSpecHttpMatchArgs:
    def __init__(__self__, *,
                 authority: Optional[Any] = None,
                 gateways: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 ignore_uri_case: Optional[pulumi.Input[bool]] = None,
                 method: Optional[Any] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 query_params: Optional[pulumi.Input[Mapping[str, Any]]] = None,
                 scheme: Optional[Any] = None,
                 source_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 source_namespace: Optional[pulumi.Input[str]] = None,
                 uri: Optional[Any] = None,
                 without_headers: Optional[pulumi.Input[Mapping[str, Any]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gateways: Names of gateways where the rule should be applied.
        :param pulumi.Input[bool] ignore_uri_case: Flag to specify whether the URI matching should be case-insensitive.
        :param pulumi.Input[str] name: The name assigned to a match.
        :param pulumi.Input[int] port: Specifies the ports on the host that is being addressed.
        :param pulumi.Input[Mapping[str, Any]] query_params: Query parameters for matching.
        :param pulumi.Input[str] source_namespace: Source namespace constraining the applicability of a rule to workloads in that namespace.
        :param pulumi.Input[Mapping[str, Any]] without_headers: withoutHeader has the same syntax with the header, but has opposite meaning.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ignore_uri_case is not None:
            pulumi.set(__self__, "ignore_uri_case", ignore_uri_case)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if query_params is not None:
            pulumi.set(__self__, "query_params", query_params)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if source_labels is not None:
            pulumi.set(__self__, "source_labels", source_labels)
        if source_namespace is not None:
            pulumi.set(__self__, "source_namespace", source_namespace)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if without_headers is not None:
            pulumi.set(__self__, "without_headers", without_headers)

    @property
    @pulumi.getter
    def authority(self) -> Optional[Any]:
        return pulumi.get(self, "authority")

    @authority.setter
    def authority(self, value: Optional[Any]):
        pulumi.set(self, "authority", value)

    @property
    @pulumi.getter
    def gateways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Names of gateways where the rule should be applied.
        """
        return pulumi.get(self, "gateways")

    @gateways.setter
    def gateways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateways", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter(name="ignoreUriCase")
    def ignore_uri_case(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to specify whether the URI matching should be case-insensitive.
        """
        return pulumi.get(self, "ignore_uri_case")

    @ignore_uri_case.setter
    def ignore_uri_case(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_uri_case", value)

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[Any]):
        pulumi.set(self, "method", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name assigned to a match.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the ports on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        Query parameters for matching.
        """
        return pulumi.get(self, "query_params")

    @query_params.setter
    def query_params(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "query_params", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[Any]:
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[Any]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter(name="sourceLabels")
    def source_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "source_labels")

    @source_labels.setter
    def source_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "source_labels", value)

    @property
    @pulumi.getter(name="sourceNamespace")
    def source_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Source namespace constraining the applicability of a rule to workloads in that namespace.
        """
        return pulumi.get(self, "source_namespace")

    @source_namespace.setter
    def source_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_namespace", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[Any]:
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[Any]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="withoutHeaders")
    def without_headers(self) -> Optional[pulumi.Input[Mapping[str, Any]]]:
        """
        withoutHeader has the same syntax with the header, but has opposite meaning.
        """
        return pulumi.get(self, "without_headers")

    @without_headers.setter
    def without_headers(self, value: Optional[pulumi.Input[Mapping[str, Any]]]):
        pulumi.set(self, "without_headers", value)


@pulumi.input_type
class VirtualServiceSpecHttpMirrorArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input['VirtualServiceSpecHttpMirrorPortArgs']] = None,
                 subset: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The name of a service from the service registry.
        :param pulumi.Input['VirtualServiceSpecHttpMirrorPortArgs'] port: Specifies the port on the host that is being addressed.
        :param pulumi.Input[str] subset: The name of a subset within the service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subset is not None:
            pulumi.set(__self__, "subset", subset)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpMirrorPortArgs']]:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpMirrorPortArgs']]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def subset(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a subset within the service.
        """
        return pulumi.get(self, "subset")

    @subset.setter
    def subset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subset", value)


@pulumi.input_type
class VirtualServiceSpecHttpMirrorPercentageArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[float]] = None):
        """
        Percentage of the traffic to be mirrored by the `mirror` field.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class VirtualServiceSpecHttpMirrorPortArgs:
    def __init__(__self__, *,
                 number: Optional[pulumi.Input[int]] = None):
        """
        Specifies the port on the host that is being addressed.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)


@pulumi.input_type
class VirtualServiceSpecHttpRetriesArgs:
    def __init__(__self__, *,
                 attempts: Optional[pulumi.Input[int]] = None,
                 per_try_timeout: Optional[pulumi.Input[str]] = None,
                 retry_on: Optional[pulumi.Input[str]] = None,
                 retry_remote_localities: Optional[pulumi.Input[bool]] = None):
        """
        Retry policy for HTTP requests.
        :param pulumi.Input[int] attempts: Number of retries to be allowed for a given request.
        :param pulumi.Input[str] per_try_timeout: Timeout per attempt for a given request, including the initial call and any retries.
        :param pulumi.Input[str] retry_on: Specifies the conditions under which retry takes place.
        :param pulumi.Input[bool] retry_remote_localities: Flag to specify whether the retries should retry to other localities.
        """
        if attempts is not None:
            pulumi.set(__self__, "attempts", attempts)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_on is not None:
            pulumi.set(__self__, "retry_on", retry_on)
        if retry_remote_localities is not None:
            pulumi.set(__self__, "retry_remote_localities", retry_remote_localities)

    @property
    @pulumi.getter
    def attempts(self) -> Optional[pulumi.Input[int]]:
        """
        Number of retries to be allowed for a given request.
        """
        return pulumi.get(self, "attempts")

    @attempts.setter
    def attempts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "attempts", value)

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout per attempt for a given request, including the initial call and any retries.
        """
        return pulumi.get(self, "per_try_timeout")

    @per_try_timeout.setter
    def per_try_timeout(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "per_try_timeout", value)

    @property
    @pulumi.getter(name="retryOn")
    def retry_on(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the conditions under which retry takes place.
        """
        return pulumi.get(self, "retry_on")

    @retry_on.setter
    def retry_on(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retry_on", value)

    @property
    @pulumi.getter(name="retryRemoteLocalities")
    def retry_remote_localities(self) -> Optional[pulumi.Input[bool]]:
        """
        Flag to specify whether the retries should retry to other localities.
        """
        return pulumi.get(self, "retry_remote_localities")

    @retry_remote_localities.setter
    def retry_remote_localities(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "retry_remote_localities", value)


@pulumi.input_type
class VirtualServiceSpecHttpRewriteArgs:
    def __init__(__self__, *,
                 authority: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        Rewrite HTTP URIs and Authority headers.
        :param pulumi.Input[str] authority: rewrite the Authority/Host header with this value.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def authority(self) -> Optional[pulumi.Input[str]]:
        """
        rewrite the Authority/Host header with this value.
        """
        return pulumi.get(self, "authority")

    @authority.setter
    def authority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authority", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


@pulumi.input_type
class VirtualServiceSpecHttpRouteArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input['VirtualServiceSpecHttpRouteDestinationArgs']] = None,
                 headers: Optional[pulumi.Input['VirtualServiceSpecHttpRouteHeadersArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] weight: Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpRouteDestinationArgs']]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpRouteDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpRouteHeadersArgs']]:
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpRouteHeadersArgs']]):
        pulumi.set(self, "headers", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class VirtualServiceSpecHttpRouteDestinationArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input['VirtualServiceSpecHttpRouteDestinationPortArgs']] = None,
                 subset: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The name of a service from the service registry.
        :param pulumi.Input['VirtualServiceSpecHttpRouteDestinationPortArgs'] port: Specifies the port on the host that is being addressed.
        :param pulumi.Input[str] subset: The name of a subset within the service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subset is not None:
            pulumi.set(__self__, "subset", subset)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpRouteDestinationPortArgs']]:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpRouteDestinationPortArgs']]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def subset(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a subset within the service.
        """
        return pulumi.get(self, "subset")

    @subset.setter
    def subset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subset", value)


@pulumi.input_type
class VirtualServiceSpecHttpRouteDestinationPortArgs:
    def __init__(__self__, *,
                 number: Optional[pulumi.Input[int]] = None):
        """
        Specifies the port on the host that is being addressed.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)


@pulumi.input_type
class VirtualServiceSpecHttpRouteHeadersArgs:
    def __init__(__self__, *,
                 request: Optional[pulumi.Input['VirtualServiceSpecHttpRouteHeadersRequestArgs']] = None,
                 response: Optional[pulumi.Input['VirtualServiceSpecHttpRouteHeadersResponseArgs']] = None):
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpRouteHeadersRequestArgs']]:
        return pulumi.get(self, "request")

    @request.setter
    def request(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpRouteHeadersRequestArgs']]):
        pulumi.set(self, "request", value)

    @property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['VirtualServiceSpecHttpRouteHeadersResponseArgs']]:
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['VirtualServiceSpecHttpRouteHeadersResponseArgs']]):
        pulumi.set(self, "response", value)


@pulumi.input_type
class VirtualServiceSpecHttpRouteHeadersRequestArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "set", value)


@pulumi.input_type
class VirtualServiceSpecHttpRouteHeadersResponseArgs:
    def __init__(__self__, *,
                 add: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 remove: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 set: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "add")

    @add.setter
    def add(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "add", value)

    @property
    @pulumi.getter
    def remove(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "remove")

    @remove.setter
    def remove(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "remove", value)

    @property
    @pulumi.getter
    def set(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "set")

    @set.setter
    def set(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "set", value)


@pulumi.input_type
class VirtualServiceSpecTcpArgs:
    def __init__(__self__, *,
                 match: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTcpMatchArgs']]]] = None,
                 route: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTcpRouteArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTcpRouteArgs']]] route: The destination to which the connection should be forwarded to.
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTcpMatchArgs']]]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTcpMatchArgs']]]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTcpRouteArgs']]]]:
        """
        The destination to which the connection should be forwarded to.
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTcpRouteArgs']]]]):
        pulumi.set(self, "route", value)


@pulumi.input_type
class VirtualServiceSpecTcpMatchArgs:
    def __init__(__self__, *,
                 destination_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gateways: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 source_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 source_namespace: Optional[pulumi.Input[str]] = None,
                 source_subnet: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_subnets: IPv4 or IPv6 ip addresses of destination with optional subnet.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gateways: Names of gateways where the rule should be applied.
        :param pulumi.Input[int] port: Specifies the port on the host that is being addressed.
        :param pulumi.Input[str] source_namespace: Source namespace constraining the applicability of a rule to workloads in that namespace.
        :param pulumi.Input[str] source_subnet: IPv4 or IPv6 ip address of source with optional subnet.
        """
        if destination_subnets is not None:
            pulumi.set(__self__, "destination_subnets", destination_subnets)
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if source_labels is not None:
            pulumi.set(__self__, "source_labels", source_labels)
        if source_namespace is not None:
            pulumi.set(__self__, "source_namespace", source_namespace)
        if source_subnet is not None:
            pulumi.set(__self__, "source_subnet", source_subnet)

    @property
    @pulumi.getter(name="destinationSubnets")
    def destination_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IPv4 or IPv6 ip addresses of destination with optional subnet.
        """
        return pulumi.get(self, "destination_subnets")

    @destination_subnets.setter
    def destination_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_subnets", value)

    @property
    @pulumi.getter
    def gateways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Names of gateways where the rule should be applied.
        """
        return pulumi.get(self, "gateways")

    @gateways.setter
    def gateways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateways", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sourceLabels")
    def source_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "source_labels")

    @source_labels.setter
    def source_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "source_labels", value)

    @property
    @pulumi.getter(name="sourceNamespace")
    def source_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Source namespace constraining the applicability of a rule to workloads in that namespace.
        """
        return pulumi.get(self, "source_namespace")

    @source_namespace.setter
    def source_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_namespace", value)

    @property
    @pulumi.getter(name="sourceSubnet")
    def source_subnet(self) -> Optional[pulumi.Input[str]]:
        """
        IPv4 or IPv6 ip address of source with optional subnet.
        """
        return pulumi.get(self, "source_subnet")

    @source_subnet.setter
    def source_subnet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_subnet", value)


@pulumi.input_type
class VirtualServiceSpecTcpRouteArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input['VirtualServiceSpecTcpRouteDestinationArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] weight: Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['VirtualServiceSpecTcpRouteDestinationArgs']]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['VirtualServiceSpecTcpRouteDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class VirtualServiceSpecTcpRouteDestinationArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input['VirtualServiceSpecTcpRouteDestinationPortArgs']] = None,
                 subset: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The name of a service from the service registry.
        :param pulumi.Input['VirtualServiceSpecTcpRouteDestinationPortArgs'] port: Specifies the port on the host that is being addressed.
        :param pulumi.Input[str] subset: The name of a subset within the service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subset is not None:
            pulumi.set(__self__, "subset", subset)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['VirtualServiceSpecTcpRouteDestinationPortArgs']]:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['VirtualServiceSpecTcpRouteDestinationPortArgs']]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def subset(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a subset within the service.
        """
        return pulumi.get(self, "subset")

    @subset.setter
    def subset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subset", value)


@pulumi.input_type
class VirtualServiceSpecTcpRouteDestinationPortArgs:
    def __init__(__self__, *,
                 number: Optional[pulumi.Input[int]] = None):
        """
        Specifies the port on the host that is being addressed.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)


@pulumi.input_type
class VirtualServiceSpecTlsArgs:
    def __init__(__self__, *,
                 match: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTlsMatchArgs']]]] = None,
                 route: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTlsRouteArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTlsRouteArgs']]] route: The destination to which the connection should be forwarded to.
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTlsMatchArgs']]]]:
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTlsMatchArgs']]]]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def route(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTlsRouteArgs']]]]:
        """
        The destination to which the connection should be forwarded to.
        """
        return pulumi.get(self, "route")

    @route.setter
    def route(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VirtualServiceSpecTlsRouteArgs']]]]):
        pulumi.set(self, "route", value)


@pulumi.input_type
class VirtualServiceSpecTlsMatchArgs:
    def __init__(__self__, *,
                 destination_subnets: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 gateways: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 sni_hosts: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 source_namespace: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_subnets: IPv4 or IPv6 ip addresses of destination with optional subnet.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] gateways: Names of gateways where the rule should be applied.
        :param pulumi.Input[int] port: Specifies the port on the host that is being addressed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] sni_hosts: SNI (server name indicator) to match on.
        :param pulumi.Input[str] source_namespace: Source namespace constraining the applicability of a rule to workloads in that namespace.
        """
        if destination_subnets is not None:
            pulumi.set(__self__, "destination_subnets", destination_subnets)
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if sni_hosts is not None:
            pulumi.set(__self__, "sni_hosts", sni_hosts)
        if source_labels is not None:
            pulumi.set(__self__, "source_labels", source_labels)
        if source_namespace is not None:
            pulumi.set(__self__, "source_namespace", source_namespace)

    @property
    @pulumi.getter(name="destinationSubnets")
    def destination_subnets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        IPv4 or IPv6 ip addresses of destination with optional subnet.
        """
        return pulumi.get(self, "destination_subnets")

    @destination_subnets.setter
    def destination_subnets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_subnets", value)

    @property
    @pulumi.getter
    def gateways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Names of gateways where the rule should be applied.
        """
        return pulumi.get(self, "gateways")

    @gateways.setter
    def gateways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "gateways", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sniHosts")
    def sni_hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        SNI (server name indicator) to match on.
        """
        return pulumi.get(self, "sni_hosts")

    @sni_hosts.setter
    def sni_hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "sni_hosts", value)

    @property
    @pulumi.getter(name="sourceLabels")
    def source_labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        return pulumi.get(self, "source_labels")

    @source_labels.setter
    def source_labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "source_labels", value)

    @property
    @pulumi.getter(name="sourceNamespace")
    def source_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Source namespace constraining the applicability of a rule to workloads in that namespace.
        """
        return pulumi.get(self, "source_namespace")

    @source_namespace.setter
    def source_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_namespace", value)


@pulumi.input_type
class VirtualServiceSpecTlsRouteArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input['VirtualServiceSpecTlsRouteDestinationArgs']] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] weight: Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['VirtualServiceSpecTlsRouteDestinationArgs']]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['VirtualServiceSpecTlsRouteDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


@pulumi.input_type
class VirtualServiceSpecTlsRouteDestinationArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input['VirtualServiceSpecTlsRouteDestinationPortArgs']] = None,
                 subset: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: The name of a service from the service registry.
        :param pulumi.Input['VirtualServiceSpecTlsRouteDestinationPortArgs'] port: Specifies the port on the host that is being addressed.
        :param pulumi.Input[str] subset: The name of a subset within the service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subset is not None:
            pulumi.set(__self__, "subset", subset)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input['VirtualServiceSpecTlsRouteDestinationPortArgs']]:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input['VirtualServiceSpecTlsRouteDestinationPortArgs']]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def subset(self) -> Optional[pulumi.Input[str]]:
        """
        The name of a subset within the service.
        """
        return pulumi.get(self, "subset")

    @subset.setter
    def subset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subset", value)


@pulumi.input_type
class VirtualServiceSpecTlsRouteDestinationPortArgs:
    def __init__(__self__, *,
                 number: Optional[pulumi.Input[int]] = None):
        """
        Specifies the port on the host that is being addressed.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number", value)


@pulumi.input_type
class WorkloadEntrySpecArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 locality: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None,
                 ports: Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]] = None,
                 service_account: Optional[pulumi.Input[str]] = None,
                 weight: Optional[pulumi.Input[int]] = None):
        """
        Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: One or more labels associated with the endpoint.
        :param pulumi.Input[str] locality: The locality associated with the endpoint.
        :param pulumi.Input[Mapping[str, pulumi.Input[int]]] ports: Set of ports associated with the endpoint.
        :param pulumi.Input[int] weight: The load balancing weight associated with the endpoint.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        One or more labels associated with the endpoint.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def locality(self) -> Optional[pulumi.Input[str]]:
        """
        The locality associated with the endpoint.
        """
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locality", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def ports(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]:
        """
        Set of ports associated with the endpoint.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]):
        pulumi.set(self, "ports", value)

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account", value)

    @property
    @pulumi.getter
    def weight(self) -> Optional[pulumi.Input[int]]:
        """
        The load balancing weight associated with the endpoint.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "weight", value)


