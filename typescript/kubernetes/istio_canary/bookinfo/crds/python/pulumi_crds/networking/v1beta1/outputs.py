# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs

__all__ = [
    'DestinationRuleSpec',
    'DestinationRuleSpecSubsets',
    'DestinationRuleSpecSubsetsTrafficPolicy',
    'DestinationRuleSpecSubsetsTrafficPolicyConnectionPool',
    'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp',
    'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp',
    'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive',
    'DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort',
    'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls',
    'DestinationRuleSpecSubsetsTrafficPolicyTls',
    'DestinationRuleSpecTrafficPolicy',
    'DestinationRuleSpecTrafficPolicyConnectionPool',
    'DestinationRuleSpecTrafficPolicyConnectionPoolHttp',
    'DestinationRuleSpecTrafficPolicyConnectionPoolTcp',
    'DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive',
    'DestinationRuleSpecTrafficPolicyOutlierDetection',
    'DestinationRuleSpecTrafficPolicyPortLevelSettings',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsPort',
    'DestinationRuleSpecTrafficPolicyPortLevelSettingsTls',
    'DestinationRuleSpecTrafficPolicyTls',
    'GatewaySpec',
    'GatewaySpecServers',
    'GatewaySpecServersPort',
    'GatewaySpecServersTls',
    'ProxyConfigSpec',
    'ProxyConfigSpecImage',
    'ProxyConfigSpecSelector',
    'ServiceEntrySpec',
    'ServiceEntrySpecEndpoints',
    'ServiceEntrySpecPorts',
    'ServiceEntrySpecWorkloadSelector',
    'SidecarSpec',
    'SidecarSpecEgress',
    'SidecarSpecEgressPort',
    'SidecarSpecIngress',
    'SidecarSpecIngressPort',
    'SidecarSpecOutboundTrafficPolicy',
    'SidecarSpecOutboundTrafficPolicyEgressProxy',
    'SidecarSpecOutboundTrafficPolicyEgressProxyPort',
    'SidecarSpecWorkloadSelector',
    'VirtualServiceSpec',
    'VirtualServiceSpecHttp',
    'VirtualServiceSpecHttpCorsPolicy',
    'VirtualServiceSpecHttpDelegate',
    'VirtualServiceSpecHttpFault',
    'VirtualServiceSpecHttpHeaders',
    'VirtualServiceSpecHttpHeadersRequest',
    'VirtualServiceSpecHttpHeadersResponse',
    'VirtualServiceSpecHttpMatch',
    'VirtualServiceSpecHttpMirror',
    'VirtualServiceSpecHttpMirrorPercentage',
    'VirtualServiceSpecHttpMirrorPort',
    'VirtualServiceSpecHttpRetries',
    'VirtualServiceSpecHttpRewrite',
    'VirtualServiceSpecHttpRoute',
    'VirtualServiceSpecHttpRouteDestination',
    'VirtualServiceSpecHttpRouteDestinationPort',
    'VirtualServiceSpecHttpRouteHeaders',
    'VirtualServiceSpecHttpRouteHeadersRequest',
    'VirtualServiceSpecHttpRouteHeadersResponse',
    'VirtualServiceSpecTcp',
    'VirtualServiceSpecTcpMatch',
    'VirtualServiceSpecTcpRoute',
    'VirtualServiceSpecTcpRouteDestination',
    'VirtualServiceSpecTcpRouteDestinationPort',
    'VirtualServiceSpecTls',
    'VirtualServiceSpecTlsMatch',
    'VirtualServiceSpecTlsRoute',
    'VirtualServiceSpecTlsRouteDestination',
    'VirtualServiceSpecTlsRouteDestinationPort',
    'WorkloadEntrySpec',
]

@pulumi.output_type
class DestinationRuleSpec(dict):
    """
    Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportTo":
            suggest = "export_to"
        elif key == "trafficPolicy":
            suggest = "traffic_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_to: Optional[Sequence[str]] = None,
                 host: Optional[str] = None,
                 subsets: Optional[Sequence['outputs.DestinationRuleSpecSubsets']] = None,
                 traffic_policy: Optional['outputs.DestinationRuleSpecTrafficPolicy'] = None):
        """
        Configuration affecting load balancing, outlier detection, etc. See more details at: https://istio.io/docs/reference/config/networking/destination-rule.html
        :param Sequence[str] export_to: A list of namespaces to which this destination rule is exported.
        :param str host: The name of a service from the service registry.
        """
        if export_to is not None:
            pulumi.set(__self__, "export_to", export_to)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if subsets is not None:
            pulumi.set(__self__, "subsets", subsets)
        if traffic_policy is not None:
            pulumi.set(__self__, "traffic_policy", traffic_policy)

    @property
    @pulumi.getter(name="exportTo")
    def export_to(self) -> Optional[Sequence[str]]:
        """
        A list of namespaces to which this destination rule is exported.
        """
        return pulumi.get(self, "export_to")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def subsets(self) -> Optional[Sequence['outputs.DestinationRuleSpecSubsets']]:
        return pulumi.get(self, "subsets")

    @property
    @pulumi.getter(name="trafficPolicy")
    def traffic_policy(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicy']:
        return pulumi.get(self, "traffic_policy")


@pulumi.output_type
class DestinationRuleSpecSubsets(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trafficPolicy":
            suggest = "traffic_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecSubsets. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecSubsets.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecSubsets.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None,
                 name: Optional[str] = None,
                 traffic_policy: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicy'] = None):
        """
        :param str name: Name of the subset.
        :param 'DestinationRuleSpecSubsetsTrafficPolicyArgs' traffic_policy: Traffic policies that apply to this subset.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if traffic_policy is not None:
            pulumi.set(__self__, "traffic_policy", traffic_policy)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of the subset.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="trafficPolicy")
    def traffic_policy(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicy']:
        """
        Traffic policies that apply to this subset.
        """
        return pulumi.get(self, "traffic_policy")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicy(dict):
    """
    Traffic policies that apply to this subset.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionPool":
            suggest = "connection_pool"
        elif key == "loadBalancer":
            suggest = "load_balancer"
        elif key == "outlierDetection":
            suggest = "outlier_detection"
        elif key == "portLevelSettings":
            suggest = "port_level_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecSubsetsTrafficPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_pool: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyConnectionPool'] = None,
                 load_balancer: Optional[Any] = None,
                 outlier_detection: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection'] = None,
                 port_level_settings: Optional[Sequence['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings']] = None,
                 tls: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyTls'] = None):
        """
        Traffic policies that apply to this subset.
        :param Any load_balancer: Settings controlling the load balancer algorithms.
        :param Sequence['DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsArgs'] port_level_settings: Traffic policies specific to individual ports.
        :param 'DestinationRuleSpecSubsetsTrafficPolicyTlsArgs' tls: TLS related settings for connections to the upstream service.
        """
        if connection_pool is not None:
            pulumi.set(__self__, "connection_pool", connection_pool)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if outlier_detection is not None:
            pulumi.set(__self__, "outlier_detection", outlier_detection)
        if port_level_settings is not None:
            pulumi.set(__self__, "port_level_settings", port_level_settings)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyConnectionPool']:
        return pulumi.get(self, "connection_pool")

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[Any]:
        """
        Settings controlling the load balancer algorithms.
        """
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter(name="outlierDetection")
    def outlier_detection(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection']:
        return pulumi.get(self, "outlier_detection")

    @property
    @pulumi.getter(name="portLevelSettings")
    def port_level_settings(self) -> Optional[Sequence['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings']]:
        """
        Traffic policies specific to individual ports.
        """
        return pulumi.get(self, "port_level_settings")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyTls']:
        """
        TLS related settings for connections to the upstream service.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyConnectionPool(dict):
    def __init__(__self__, *,
                 http: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp'] = None,
                 tcp: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp'] = None):
        """
        :param 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttpArgs' http: HTTP connection pool settings.
        :param 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpArgs' tcp: Settings common to both HTTP and TCP upstream connections.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp']:
        """
        HTTP connection pool settings.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp']:
        """
        Settings common to both HTTP and TCP upstream connections.
        """
        return pulumi.get(self, "tcp")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp(dict):
    """
    HTTP connection pool settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h2UpgradePolicy":
            suggest = "h2_upgrade_policy"
        elif key == "http1MaxPendingRequests":
            suggest = "http1_max_pending_requests"
        elif key == "http2MaxRequests":
            suggest = "http2_max_requests"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "maxRequestsPerConnection":
            suggest = "max_requests_per_connection"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "useClientProtocol":
            suggest = "use_client_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 h2_upgrade_policy: Optional[str] = None,
                 http1_max_pending_requests: Optional[int] = None,
                 http2_max_requests: Optional[int] = None,
                 idle_timeout: Optional[str] = None,
                 max_requests_per_connection: Optional[int] = None,
                 max_retries: Optional[int] = None,
                 use_client_protocol: Optional[bool] = None):
        """
        HTTP connection pool settings.
        :param str h2_upgrade_policy: Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        :param int http1_max_pending_requests: Maximum number of pending HTTP requests to a destination.
        :param int http2_max_requests: Maximum number of requests to a backend.
        :param str idle_timeout: The idle timeout for upstream connection pool connections.
        :param int max_requests_per_connection: Maximum number of requests per connection to a backend.
        :param bool use_client_protocol: If set to true, client protocol will be preserved while initiating connection to backend.
        """
        if h2_upgrade_policy is not None:
            pulumi.set(__self__, "h2_upgrade_policy", h2_upgrade_policy)
        if http1_max_pending_requests is not None:
            pulumi.set(__self__, "http1_max_pending_requests", http1_max_pending_requests)
        if http2_max_requests is not None:
            pulumi.set(__self__, "http2_max_requests", http2_max_requests)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if use_client_protocol is not None:
            pulumi.set(__self__, "use_client_protocol", use_client_protocol)

    @property
    @pulumi.getter(name="h2UpgradePolicy")
    def h2_upgrade_policy(self) -> Optional[str]:
        """
        Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        """
        return pulumi.get(self, "h2_upgrade_policy")

    @property
    @pulumi.getter(name="http1MaxPendingRequests")
    def http1_max_pending_requests(self) -> Optional[int]:
        """
        Maximum number of pending HTTP requests to a destination.
        """
        return pulumi.get(self, "http1_max_pending_requests")

    @property
    @pulumi.getter(name="http2MaxRequests")
    def http2_max_requests(self) -> Optional[int]:
        """
        Maximum number of requests to a backend.
        """
        return pulumi.get(self, "http2_max_requests")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[str]:
        """
        The idle timeout for upstream connection pool connections.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[int]:
        """
        Maximum number of requests per connection to a backend.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="useClientProtocol")
    def use_client_protocol(self) -> Optional[bool]:
        """
        If set to true, client protocol will be preserved while initiating connection to backend.
        """
        return pulumi.get(self, "use_client_protocol")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp(dict):
    """
    Settings common to both HTTP and TCP upstream connections.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "tcpKeepalive":
            suggest = "tcp_keepalive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connect_timeout: Optional[str] = None,
                 max_connections: Optional[int] = None,
                 tcp_keepalive: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive'] = None):
        """
        Settings common to both HTTP and TCP upstream connections.
        :param str connect_timeout: TCP connection timeout.
        :param int max_connections: Maximum number of HTTP1 /TCP connections to a destination host.
        :param 'DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs' tcp_keepalive: If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if tcp_keepalive is not None:
            pulumi.set(__self__, "tcp_keepalive", tcp_keepalive)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[str]:
        """
        TCP connection timeout.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        Maximum number of HTTP1 /TCP connections to a destination host.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="tcpKeepalive")
    def tcp_keepalive(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive']:
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        return pulumi.get(self, "tcp_keepalive")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyConnectionPoolTcpTcpKeepalive(dict):
    """
    If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    """
    def __init__(__self__, *,
                 interval: Optional[str] = None,
                 probes: Optional[int] = None,
                 time: Optional[str] = None):
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        :param str interval: The time duration between keep-alive probes.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        """
        The time duration between keep-alive probes.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def probes(self) -> Optional[int]:
        return pulumi.get(self, "probes")

    @property
    @pulumi.getter
    def time(self) -> Optional[str]:
        return pulumi.get(self, "time")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseEjectionTime":
            suggest = "base_ejection_time"
        elif key == "consecutive5xxErrors":
            suggest = "consecutive5xx_errors"
        elif key == "consecutiveErrors":
            suggest = "consecutive_errors"
        elif key == "consecutiveGatewayErrors":
            suggest = "consecutive_gateway_errors"
        elif key == "consecutiveLocalOriginFailures":
            suggest = "consecutive_local_origin_failures"
        elif key == "maxEjectionPercent":
            suggest = "max_ejection_percent"
        elif key == "minHealthPercent":
            suggest = "min_health_percent"
        elif key == "splitExternalLocalOriginErrors":
            suggest = "split_external_local_origin_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyOutlierDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_ejection_time: Optional[str] = None,
                 consecutive5xx_errors: Optional[int] = None,
                 consecutive_errors: Optional[int] = None,
                 consecutive_gateway_errors: Optional[int] = None,
                 consecutive_local_origin_failures: Optional[int] = None,
                 interval: Optional[str] = None,
                 max_ejection_percent: Optional[int] = None,
                 min_health_percent: Optional[int] = None,
                 split_external_local_origin_errors: Optional[bool] = None):
        """
        :param str base_ejection_time: Minimum ejection duration.
        :param int consecutive5xx_errors: Number of 5xx errors before a host is ejected from the connection pool.
        :param int consecutive_gateway_errors: Number of gateway errors before a host is ejected from the connection pool.
        :param str interval: Time interval between ejection sweep analysis.
        :param bool split_external_local_origin_errors: Determines whether to distinguish local origin failures from external errors.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive5xx_errors is not None:
            pulumi.set(__self__, "consecutive5xx_errors", consecutive5xx_errors)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_errors is not None:
            pulumi.set(__self__, "consecutive_gateway_errors", consecutive_gateway_errors)
        if consecutive_local_origin_failures is not None:
            pulumi.set(__self__, "consecutive_local_origin_failures", consecutive_local_origin_failures)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if min_health_percent is not None:
            pulumi.set(__self__, "min_health_percent", min_health_percent)
        if split_external_local_origin_errors is not None:
            pulumi.set(__self__, "split_external_local_origin_errors", split_external_local_origin_errors)

    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional[str]:
        """
        Minimum ejection duration.
        """
        return pulumi.get(self, "base_ejection_time")

    @property
    @pulumi.getter(name="consecutive5xxErrors")
    def consecutive5xx_errors(self) -> Optional[int]:
        """
        Number of 5xx errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive5xx_errors")

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[int]:
        return pulumi.get(self, "consecutive_errors")

    @property
    @pulumi.getter(name="consecutiveGatewayErrors")
    def consecutive_gateway_errors(self) -> Optional[int]:
        """
        Number of gateway errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive_gateway_errors")

    @property
    @pulumi.getter(name="consecutiveLocalOriginFailures")
    def consecutive_local_origin_failures(self) -> Optional[int]:
        return pulumi.get(self, "consecutive_local_origin_failures")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        """
        Time interval between ejection sweep analysis.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[int]:
        return pulumi.get(self, "max_ejection_percent")

    @property
    @pulumi.getter(name="minHealthPercent")
    def min_health_percent(self) -> Optional[int]:
        return pulumi.get(self, "min_health_percent")

    @property
    @pulumi.getter(name="splitExternalLocalOriginErrors")
    def split_external_local_origin_errors(self) -> Optional[bool]:
        """
        Determines whether to distinguish local origin failures from external errors.
        """
        return pulumi.get(self, "split_external_local_origin_errors")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionPool":
            suggest = "connection_pool"
        elif key == "loadBalancer":
            suggest = "load_balancer"
        elif key == "outlierDetection":
            suggest = "outlier_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_pool: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool'] = None,
                 load_balancer: Optional[Any] = None,
                 outlier_detection: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection'] = None,
                 port: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort'] = None,
                 tls: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls'] = None):
        """
        :param Any load_balancer: Settings controlling the load balancer algorithms.
        :param 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTlsArgs' tls: TLS related settings for connections to the upstream service.
        """
        if connection_pool is not None:
            pulumi.set(__self__, "connection_pool", connection_pool)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if outlier_detection is not None:
            pulumi.set(__self__, "outlier_detection", outlier_detection)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool']:
        return pulumi.get(self, "connection_pool")

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[Any]:
        """
        Settings controlling the load balancer algorithms.
        """
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter(name="outlierDetection")
    def outlier_detection(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection']:
        return pulumi.get(self, "outlier_detection")

    @property
    @pulumi.getter
    def port(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort']:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls']:
        """
        TLS related settings for connections to the upstream service.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPool(dict):
    def __init__(__self__, *,
                 http: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp'] = None,
                 tcp: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp'] = None):
        """
        :param 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs' http: HTTP connection pool settings.
        :param 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs' tcp: Settings common to both HTTP and TCP upstream connections.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp']:
        """
        HTTP connection pool settings.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp']:
        """
        Settings common to both HTTP and TCP upstream connections.
        """
        return pulumi.get(self, "tcp")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp(dict):
    """
    HTTP connection pool settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h2UpgradePolicy":
            suggest = "h2_upgrade_policy"
        elif key == "http1MaxPendingRequests":
            suggest = "http1_max_pending_requests"
        elif key == "http2MaxRequests":
            suggest = "http2_max_requests"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "maxRequestsPerConnection":
            suggest = "max_requests_per_connection"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "useClientProtocol":
            suggest = "use_client_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 h2_upgrade_policy: Optional[str] = None,
                 http1_max_pending_requests: Optional[int] = None,
                 http2_max_requests: Optional[int] = None,
                 idle_timeout: Optional[str] = None,
                 max_requests_per_connection: Optional[int] = None,
                 max_retries: Optional[int] = None,
                 use_client_protocol: Optional[bool] = None):
        """
        HTTP connection pool settings.
        :param str h2_upgrade_policy: Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        :param int http1_max_pending_requests: Maximum number of pending HTTP requests to a destination.
        :param int http2_max_requests: Maximum number of requests to a backend.
        :param str idle_timeout: The idle timeout for upstream connection pool connections.
        :param int max_requests_per_connection: Maximum number of requests per connection to a backend.
        :param bool use_client_protocol: If set to true, client protocol will be preserved while initiating connection to backend.
        """
        if h2_upgrade_policy is not None:
            pulumi.set(__self__, "h2_upgrade_policy", h2_upgrade_policy)
        if http1_max_pending_requests is not None:
            pulumi.set(__self__, "http1_max_pending_requests", http1_max_pending_requests)
        if http2_max_requests is not None:
            pulumi.set(__self__, "http2_max_requests", http2_max_requests)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if use_client_protocol is not None:
            pulumi.set(__self__, "use_client_protocol", use_client_protocol)

    @property
    @pulumi.getter(name="h2UpgradePolicy")
    def h2_upgrade_policy(self) -> Optional[str]:
        """
        Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        """
        return pulumi.get(self, "h2_upgrade_policy")

    @property
    @pulumi.getter(name="http1MaxPendingRequests")
    def http1_max_pending_requests(self) -> Optional[int]:
        """
        Maximum number of pending HTTP requests to a destination.
        """
        return pulumi.get(self, "http1_max_pending_requests")

    @property
    @pulumi.getter(name="http2MaxRequests")
    def http2_max_requests(self) -> Optional[int]:
        """
        Maximum number of requests to a backend.
        """
        return pulumi.get(self, "http2_max_requests")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[str]:
        """
        The idle timeout for upstream connection pool connections.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[int]:
        """
        Maximum number of requests per connection to a backend.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="useClientProtocol")
    def use_client_protocol(self) -> Optional[bool]:
        """
        If set to true, client protocol will be preserved while initiating connection to backend.
        """
        return pulumi.get(self, "use_client_protocol")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp(dict):
    """
    Settings common to both HTTP and TCP upstream connections.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "tcpKeepalive":
            suggest = "tcp_keepalive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connect_timeout: Optional[str] = None,
                 max_connections: Optional[int] = None,
                 tcp_keepalive: Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive'] = None):
        """
        Settings common to both HTTP and TCP upstream connections.
        :param str connect_timeout: TCP connection timeout.
        :param int max_connections: Maximum number of HTTP1 /TCP connections to a destination host.
        :param 'DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs' tcp_keepalive: If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if tcp_keepalive is not None:
            pulumi.set(__self__, "tcp_keepalive", tcp_keepalive)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[str]:
        """
        TCP connection timeout.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        Maximum number of HTTP1 /TCP connections to a destination host.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="tcpKeepalive")
    def tcp_keepalive(self) -> Optional['outputs.DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive']:
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        return pulumi.get(self, "tcp_keepalive")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(dict):
    """
    If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    """
    def __init__(__self__, *,
                 interval: Optional[str] = None,
                 probes: Optional[int] = None,
                 time: Optional[str] = None):
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        :param str interval: The time duration between keep-alive probes.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        """
        The time duration between keep-alive probes.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def probes(self) -> Optional[int]:
        return pulumi.get(self, "probes")

    @property
    @pulumi.getter
    def time(self) -> Optional[str]:
        return pulumi.get(self, "time")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseEjectionTime":
            suggest = "base_ejection_time"
        elif key == "consecutive5xxErrors":
            suggest = "consecutive5xx_errors"
        elif key == "consecutiveErrors":
            suggest = "consecutive_errors"
        elif key == "consecutiveGatewayErrors":
            suggest = "consecutive_gateway_errors"
        elif key == "consecutiveLocalOriginFailures":
            suggest = "consecutive_local_origin_failures"
        elif key == "maxEjectionPercent":
            suggest = "max_ejection_percent"
        elif key == "minHealthPercent":
            suggest = "min_health_percent"
        elif key == "splitExternalLocalOriginErrors":
            suggest = "split_external_local_origin_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsOutlierDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_ejection_time: Optional[str] = None,
                 consecutive5xx_errors: Optional[int] = None,
                 consecutive_errors: Optional[int] = None,
                 consecutive_gateway_errors: Optional[int] = None,
                 consecutive_local_origin_failures: Optional[int] = None,
                 interval: Optional[str] = None,
                 max_ejection_percent: Optional[int] = None,
                 min_health_percent: Optional[int] = None,
                 split_external_local_origin_errors: Optional[bool] = None):
        """
        :param str base_ejection_time: Minimum ejection duration.
        :param int consecutive5xx_errors: Number of 5xx errors before a host is ejected from the connection pool.
        :param int consecutive_gateway_errors: Number of gateway errors before a host is ejected from the connection pool.
        :param str interval: Time interval between ejection sweep analysis.
        :param bool split_external_local_origin_errors: Determines whether to distinguish local origin failures from external errors.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive5xx_errors is not None:
            pulumi.set(__self__, "consecutive5xx_errors", consecutive5xx_errors)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_errors is not None:
            pulumi.set(__self__, "consecutive_gateway_errors", consecutive_gateway_errors)
        if consecutive_local_origin_failures is not None:
            pulumi.set(__self__, "consecutive_local_origin_failures", consecutive_local_origin_failures)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if min_health_percent is not None:
            pulumi.set(__self__, "min_health_percent", min_health_percent)
        if split_external_local_origin_errors is not None:
            pulumi.set(__self__, "split_external_local_origin_errors", split_external_local_origin_errors)

    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional[str]:
        """
        Minimum ejection duration.
        """
        return pulumi.get(self, "base_ejection_time")

    @property
    @pulumi.getter(name="consecutive5xxErrors")
    def consecutive5xx_errors(self) -> Optional[int]:
        """
        Number of 5xx errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive5xx_errors")

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[int]:
        return pulumi.get(self, "consecutive_errors")

    @property
    @pulumi.getter(name="consecutiveGatewayErrors")
    def consecutive_gateway_errors(self) -> Optional[int]:
        """
        Number of gateway errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive_gateway_errors")

    @property
    @pulumi.getter(name="consecutiveLocalOriginFailures")
    def consecutive_local_origin_failures(self) -> Optional[int]:
        return pulumi.get(self, "consecutive_local_origin_failures")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        """
        Time interval between ejection sweep analysis.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[int]:
        return pulumi.get(self, "max_ejection_percent")

    @property
    @pulumi.getter(name="minHealthPercent")
    def min_health_percent(self) -> Optional[int]:
        return pulumi.get(self, "min_health_percent")

    @property
    @pulumi.getter(name="splitExternalLocalOriginErrors")
    def split_external_local_origin_errors(self) -> Optional[bool]:
        """
        Determines whether to distinguish local origin failures from external errors.
        """
        return pulumi.get(self, "split_external_local_origin_errors")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsPort(dict):
    def __init__(__self__, *,
                 number: Optional[int] = None):
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        return pulumi.get(self, "number")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls(dict):
    """
    TLS related settings for connections to the upstream service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificates":
            suggest = "ca_certificates"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "credentialName":
            suggest = "credential_name"
        elif key == "insecureSkipVerify":
            suggest = "insecure_skip_verify"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "subjectAltNames":
            suggest = "subject_alt_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyPortLevelSettingsTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificates: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 credential_name: Optional[str] = None,
                 insecure_skip_verify: Optional[bool] = None,
                 mode: Optional[str] = None,
                 private_key: Optional[str] = None,
                 sni: Optional[str] = None,
                 subject_alt_names: Optional[Sequence[str]] = None):
        """
        TLS related settings for connections to the upstream service.
        :param str client_certificate: REQUIRED if mode is `MUTUAL`.
        :param str private_key: REQUIRED if mode is `MUTUAL`.
        :param str sni: SNI string to present to the server during TLS handshake.
        """
        if ca_certificates is not None:
            pulumi.set(__self__, "ca_certificates", ca_certificates)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter(name="caCertificates")
    def ca_certificates(self) -> Optional[str]:
        return pulumi.get(self, "ca_certificates")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[str]:
        return pulumi.get(self, "credential_name")

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[bool]:
        return pulumi.get(self, "insecure_skip_verify")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def sni(self) -> Optional[str]:
        """
        SNI string to present to the server during TLS handshake.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class DestinationRuleSpecSubsetsTrafficPolicyTls(dict):
    """
    TLS related settings for connections to the upstream service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificates":
            suggest = "ca_certificates"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "credentialName":
            suggest = "credential_name"
        elif key == "insecureSkipVerify":
            suggest = "insecure_skip_verify"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "subjectAltNames":
            suggest = "subject_alt_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecSubsetsTrafficPolicyTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecSubsetsTrafficPolicyTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificates: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 credential_name: Optional[str] = None,
                 insecure_skip_verify: Optional[bool] = None,
                 mode: Optional[str] = None,
                 private_key: Optional[str] = None,
                 sni: Optional[str] = None,
                 subject_alt_names: Optional[Sequence[str]] = None):
        """
        TLS related settings for connections to the upstream service.
        :param str client_certificate: REQUIRED if mode is `MUTUAL`.
        :param str private_key: REQUIRED if mode is `MUTUAL`.
        :param str sni: SNI string to present to the server during TLS handshake.
        """
        if ca_certificates is not None:
            pulumi.set(__self__, "ca_certificates", ca_certificates)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter(name="caCertificates")
    def ca_certificates(self) -> Optional[str]:
        return pulumi.get(self, "ca_certificates")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[str]:
        return pulumi.get(self, "credential_name")

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[bool]:
        return pulumi.get(self, "insecure_skip_verify")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def sni(self) -> Optional[str]:
        """
        SNI string to present to the server during TLS handshake.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionPool":
            suggest = "connection_pool"
        elif key == "loadBalancer":
            suggest = "load_balancer"
        elif key == "outlierDetection":
            suggest = "outlier_detection"
        elif key == "portLevelSettings":
            suggest = "port_level_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecTrafficPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecTrafficPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecTrafficPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_pool: Optional['outputs.DestinationRuleSpecTrafficPolicyConnectionPool'] = None,
                 load_balancer: Optional[Any] = None,
                 outlier_detection: Optional['outputs.DestinationRuleSpecTrafficPolicyOutlierDetection'] = None,
                 port_level_settings: Optional[Sequence['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettings']] = None,
                 tls: Optional['outputs.DestinationRuleSpecTrafficPolicyTls'] = None):
        """
        :param Any load_balancer: Settings controlling the load balancer algorithms.
        :param Sequence['DestinationRuleSpecTrafficPolicyPortLevelSettingsArgs'] port_level_settings: Traffic policies specific to individual ports.
        :param 'DestinationRuleSpecTrafficPolicyTlsArgs' tls: TLS related settings for connections to the upstream service.
        """
        if connection_pool is not None:
            pulumi.set(__self__, "connection_pool", connection_pool)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if outlier_detection is not None:
            pulumi.set(__self__, "outlier_detection", outlier_detection)
        if port_level_settings is not None:
            pulumi.set(__self__, "port_level_settings", port_level_settings)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyConnectionPool']:
        return pulumi.get(self, "connection_pool")

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[Any]:
        """
        Settings controlling the load balancer algorithms.
        """
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter(name="outlierDetection")
    def outlier_detection(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyOutlierDetection']:
        return pulumi.get(self, "outlier_detection")

    @property
    @pulumi.getter(name="portLevelSettings")
    def port_level_settings(self) -> Optional[Sequence['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettings']]:
        """
        Traffic policies specific to individual ports.
        """
        return pulumi.get(self, "port_level_settings")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyTls']:
        """
        TLS related settings for connections to the upstream service.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyConnectionPool(dict):
    def __init__(__self__, *,
                 http: Optional['outputs.DestinationRuleSpecTrafficPolicyConnectionPoolHttp'] = None,
                 tcp: Optional['outputs.DestinationRuleSpecTrafficPolicyConnectionPoolTcp'] = None):
        """
        :param 'DestinationRuleSpecTrafficPolicyConnectionPoolHttpArgs' http: HTTP connection pool settings.
        :param 'DestinationRuleSpecTrafficPolicyConnectionPoolTcpArgs' tcp: Settings common to both HTTP and TCP upstream connections.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyConnectionPoolHttp']:
        """
        HTTP connection pool settings.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyConnectionPoolTcp']:
        """
        Settings common to both HTTP and TCP upstream connections.
        """
        return pulumi.get(self, "tcp")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyConnectionPoolHttp(dict):
    """
    HTTP connection pool settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h2UpgradePolicy":
            suggest = "h2_upgrade_policy"
        elif key == "http1MaxPendingRequests":
            suggest = "http1_max_pending_requests"
        elif key == "http2MaxRequests":
            suggest = "http2_max_requests"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "maxRequestsPerConnection":
            suggest = "max_requests_per_connection"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "useClientProtocol":
            suggest = "use_client_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecTrafficPolicyConnectionPoolHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecTrafficPolicyConnectionPoolHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecTrafficPolicyConnectionPoolHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 h2_upgrade_policy: Optional[str] = None,
                 http1_max_pending_requests: Optional[int] = None,
                 http2_max_requests: Optional[int] = None,
                 idle_timeout: Optional[str] = None,
                 max_requests_per_connection: Optional[int] = None,
                 max_retries: Optional[int] = None,
                 use_client_protocol: Optional[bool] = None):
        """
        HTTP connection pool settings.
        :param str h2_upgrade_policy: Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        :param int http1_max_pending_requests: Maximum number of pending HTTP requests to a destination.
        :param int http2_max_requests: Maximum number of requests to a backend.
        :param str idle_timeout: The idle timeout for upstream connection pool connections.
        :param int max_requests_per_connection: Maximum number of requests per connection to a backend.
        :param bool use_client_protocol: If set to true, client protocol will be preserved while initiating connection to backend.
        """
        if h2_upgrade_policy is not None:
            pulumi.set(__self__, "h2_upgrade_policy", h2_upgrade_policy)
        if http1_max_pending_requests is not None:
            pulumi.set(__self__, "http1_max_pending_requests", http1_max_pending_requests)
        if http2_max_requests is not None:
            pulumi.set(__self__, "http2_max_requests", http2_max_requests)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if use_client_protocol is not None:
            pulumi.set(__self__, "use_client_protocol", use_client_protocol)

    @property
    @pulumi.getter(name="h2UpgradePolicy")
    def h2_upgrade_policy(self) -> Optional[str]:
        """
        Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        """
        return pulumi.get(self, "h2_upgrade_policy")

    @property
    @pulumi.getter(name="http1MaxPendingRequests")
    def http1_max_pending_requests(self) -> Optional[int]:
        """
        Maximum number of pending HTTP requests to a destination.
        """
        return pulumi.get(self, "http1_max_pending_requests")

    @property
    @pulumi.getter(name="http2MaxRequests")
    def http2_max_requests(self) -> Optional[int]:
        """
        Maximum number of requests to a backend.
        """
        return pulumi.get(self, "http2_max_requests")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[str]:
        """
        The idle timeout for upstream connection pool connections.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[int]:
        """
        Maximum number of requests per connection to a backend.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="useClientProtocol")
    def use_client_protocol(self) -> Optional[bool]:
        """
        If set to true, client protocol will be preserved while initiating connection to backend.
        """
        return pulumi.get(self, "use_client_protocol")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyConnectionPoolTcp(dict):
    """
    Settings common to both HTTP and TCP upstream connections.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "tcpKeepalive":
            suggest = "tcp_keepalive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecTrafficPolicyConnectionPoolTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecTrafficPolicyConnectionPoolTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecTrafficPolicyConnectionPoolTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connect_timeout: Optional[str] = None,
                 max_connections: Optional[int] = None,
                 tcp_keepalive: Optional['outputs.DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive'] = None):
        """
        Settings common to both HTTP and TCP upstream connections.
        :param str connect_timeout: TCP connection timeout.
        :param int max_connections: Maximum number of HTTP1 /TCP connections to a destination host.
        :param 'DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepaliveArgs' tcp_keepalive: If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if tcp_keepalive is not None:
            pulumi.set(__self__, "tcp_keepalive", tcp_keepalive)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[str]:
        """
        TCP connection timeout.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        Maximum number of HTTP1 /TCP connections to a destination host.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="tcpKeepalive")
    def tcp_keepalive(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive']:
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        return pulumi.get(self, "tcp_keepalive")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyConnectionPoolTcpTcpKeepalive(dict):
    """
    If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    """
    def __init__(__self__, *,
                 interval: Optional[str] = None,
                 probes: Optional[int] = None,
                 time: Optional[str] = None):
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        :param str interval: The time duration between keep-alive probes.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        """
        The time duration between keep-alive probes.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def probes(self) -> Optional[int]:
        return pulumi.get(self, "probes")

    @property
    @pulumi.getter
    def time(self) -> Optional[str]:
        return pulumi.get(self, "time")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyOutlierDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseEjectionTime":
            suggest = "base_ejection_time"
        elif key == "consecutive5xxErrors":
            suggest = "consecutive5xx_errors"
        elif key == "consecutiveErrors":
            suggest = "consecutive_errors"
        elif key == "consecutiveGatewayErrors":
            suggest = "consecutive_gateway_errors"
        elif key == "consecutiveLocalOriginFailures":
            suggest = "consecutive_local_origin_failures"
        elif key == "maxEjectionPercent":
            suggest = "max_ejection_percent"
        elif key == "minHealthPercent":
            suggest = "min_health_percent"
        elif key == "splitExternalLocalOriginErrors":
            suggest = "split_external_local_origin_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecTrafficPolicyOutlierDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecTrafficPolicyOutlierDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecTrafficPolicyOutlierDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_ejection_time: Optional[str] = None,
                 consecutive5xx_errors: Optional[int] = None,
                 consecutive_errors: Optional[int] = None,
                 consecutive_gateway_errors: Optional[int] = None,
                 consecutive_local_origin_failures: Optional[int] = None,
                 interval: Optional[str] = None,
                 max_ejection_percent: Optional[int] = None,
                 min_health_percent: Optional[int] = None,
                 split_external_local_origin_errors: Optional[bool] = None):
        """
        :param str base_ejection_time: Minimum ejection duration.
        :param int consecutive5xx_errors: Number of 5xx errors before a host is ejected from the connection pool.
        :param int consecutive_gateway_errors: Number of gateway errors before a host is ejected from the connection pool.
        :param str interval: Time interval between ejection sweep analysis.
        :param bool split_external_local_origin_errors: Determines whether to distinguish local origin failures from external errors.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive5xx_errors is not None:
            pulumi.set(__self__, "consecutive5xx_errors", consecutive5xx_errors)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_errors is not None:
            pulumi.set(__self__, "consecutive_gateway_errors", consecutive_gateway_errors)
        if consecutive_local_origin_failures is not None:
            pulumi.set(__self__, "consecutive_local_origin_failures", consecutive_local_origin_failures)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if min_health_percent is not None:
            pulumi.set(__self__, "min_health_percent", min_health_percent)
        if split_external_local_origin_errors is not None:
            pulumi.set(__self__, "split_external_local_origin_errors", split_external_local_origin_errors)

    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional[str]:
        """
        Minimum ejection duration.
        """
        return pulumi.get(self, "base_ejection_time")

    @property
    @pulumi.getter(name="consecutive5xxErrors")
    def consecutive5xx_errors(self) -> Optional[int]:
        """
        Number of 5xx errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive5xx_errors")

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[int]:
        return pulumi.get(self, "consecutive_errors")

    @property
    @pulumi.getter(name="consecutiveGatewayErrors")
    def consecutive_gateway_errors(self) -> Optional[int]:
        """
        Number of gateway errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive_gateway_errors")

    @property
    @pulumi.getter(name="consecutiveLocalOriginFailures")
    def consecutive_local_origin_failures(self) -> Optional[int]:
        return pulumi.get(self, "consecutive_local_origin_failures")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        """
        Time interval between ejection sweep analysis.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[int]:
        return pulumi.get(self, "max_ejection_percent")

    @property
    @pulumi.getter(name="minHealthPercent")
    def min_health_percent(self) -> Optional[int]:
        return pulumi.get(self, "min_health_percent")

    @property
    @pulumi.getter(name="splitExternalLocalOriginErrors")
    def split_external_local_origin_errors(self) -> Optional[bool]:
        """
        Determines whether to distinguish local origin failures from external errors.
        """
        return pulumi.get(self, "split_external_local_origin_errors")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyPortLevelSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionPool":
            suggest = "connection_pool"
        elif key == "loadBalancer":
            suggest = "load_balancer"
        elif key == "outlierDetection":
            suggest = "outlier_detection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecTrafficPolicyPortLevelSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecTrafficPolicyPortLevelSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecTrafficPolicyPortLevelSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connection_pool: Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool'] = None,
                 load_balancer: Optional[Any] = None,
                 outlier_detection: Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection'] = None,
                 port: Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsPort'] = None,
                 tls: Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsTls'] = None):
        """
        :param Any load_balancer: Settings controlling the load balancer algorithms.
        :param 'DestinationRuleSpecTrafficPolicyPortLevelSettingsTlsArgs' tls: TLS related settings for connections to the upstream service.
        """
        if connection_pool is not None:
            pulumi.set(__self__, "connection_pool", connection_pool)
        if load_balancer is not None:
            pulumi.set(__self__, "load_balancer", load_balancer)
        if outlier_detection is not None:
            pulumi.set(__self__, "outlier_detection", outlier_detection)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="connectionPool")
    def connection_pool(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool']:
        return pulumi.get(self, "connection_pool")

    @property
    @pulumi.getter(name="loadBalancer")
    def load_balancer(self) -> Optional[Any]:
        """
        Settings controlling the load balancer algorithms.
        """
        return pulumi.get(self, "load_balancer")

    @property
    @pulumi.getter(name="outlierDetection")
    def outlier_detection(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection']:
        return pulumi.get(self, "outlier_detection")

    @property
    @pulumi.getter
    def port(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsPort']:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsTls']:
        """
        TLS related settings for connections to the upstream service.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPool(dict):
    def __init__(__self__, *,
                 http: Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp'] = None,
                 tcp: Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp'] = None):
        """
        :param 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttpArgs' http: HTTP connection pool settings.
        :param 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpArgs' tcp: Settings common to both HTTP and TCP upstream connections.
        """
        if http is not None:
            pulumi.set(__self__, "http", http)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)

    @property
    @pulumi.getter
    def http(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp']:
        """
        HTTP connection pool settings.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def tcp(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp']:
        """
        Settings common to both HTTP and TCP upstream connections.
        """
        return pulumi.get(self, "tcp")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp(dict):
    """
    HTTP connection pool settings.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h2UpgradePolicy":
            suggest = "h2_upgrade_policy"
        elif key == "http1MaxPendingRequests":
            suggest = "http1_max_pending_requests"
        elif key == "http2MaxRequests":
            suggest = "http2_max_requests"
        elif key == "idleTimeout":
            suggest = "idle_timeout"
        elif key == "maxRequestsPerConnection":
            suggest = "max_requests_per_connection"
        elif key == "maxRetries":
            suggest = "max_retries"
        elif key == "useClientProtocol":
            suggest = "use_client_protocol"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 h2_upgrade_policy: Optional[str] = None,
                 http1_max_pending_requests: Optional[int] = None,
                 http2_max_requests: Optional[int] = None,
                 idle_timeout: Optional[str] = None,
                 max_requests_per_connection: Optional[int] = None,
                 max_retries: Optional[int] = None,
                 use_client_protocol: Optional[bool] = None):
        """
        HTTP connection pool settings.
        :param str h2_upgrade_policy: Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        :param int http1_max_pending_requests: Maximum number of pending HTTP requests to a destination.
        :param int http2_max_requests: Maximum number of requests to a backend.
        :param str idle_timeout: The idle timeout for upstream connection pool connections.
        :param int max_requests_per_connection: Maximum number of requests per connection to a backend.
        :param bool use_client_protocol: If set to true, client protocol will be preserved while initiating connection to backend.
        """
        if h2_upgrade_policy is not None:
            pulumi.set(__self__, "h2_upgrade_policy", h2_upgrade_policy)
        if http1_max_pending_requests is not None:
            pulumi.set(__self__, "http1_max_pending_requests", http1_max_pending_requests)
        if http2_max_requests is not None:
            pulumi.set(__self__, "http2_max_requests", http2_max_requests)
        if idle_timeout is not None:
            pulumi.set(__self__, "idle_timeout", idle_timeout)
        if max_requests_per_connection is not None:
            pulumi.set(__self__, "max_requests_per_connection", max_requests_per_connection)
        if max_retries is not None:
            pulumi.set(__self__, "max_retries", max_retries)
        if use_client_protocol is not None:
            pulumi.set(__self__, "use_client_protocol", use_client_protocol)

    @property
    @pulumi.getter(name="h2UpgradePolicy")
    def h2_upgrade_policy(self) -> Optional[str]:
        """
        Specify if http1.1 connection should be upgraded to http2 for the associated destination.
        """
        return pulumi.get(self, "h2_upgrade_policy")

    @property
    @pulumi.getter(name="http1MaxPendingRequests")
    def http1_max_pending_requests(self) -> Optional[int]:
        """
        Maximum number of pending HTTP requests to a destination.
        """
        return pulumi.get(self, "http1_max_pending_requests")

    @property
    @pulumi.getter(name="http2MaxRequests")
    def http2_max_requests(self) -> Optional[int]:
        """
        Maximum number of requests to a backend.
        """
        return pulumi.get(self, "http2_max_requests")

    @property
    @pulumi.getter(name="idleTimeout")
    def idle_timeout(self) -> Optional[str]:
        """
        The idle timeout for upstream connection pool connections.
        """
        return pulumi.get(self, "idle_timeout")

    @property
    @pulumi.getter(name="maxRequestsPerConnection")
    def max_requests_per_connection(self) -> Optional[int]:
        """
        Maximum number of requests per connection to a backend.
        """
        return pulumi.get(self, "max_requests_per_connection")

    @property
    @pulumi.getter(name="maxRetries")
    def max_retries(self) -> Optional[int]:
        return pulumi.get(self, "max_retries")

    @property
    @pulumi.getter(name="useClientProtocol")
    def use_client_protocol(self) -> Optional[bool]:
        """
        If set to true, client protocol will be preserved while initiating connection to backend.
        """
        return pulumi.get(self, "use_client_protocol")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp(dict):
    """
    Settings common to both HTTP and TCP upstream connections.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectTimeout":
            suggest = "connect_timeout"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "tcpKeepalive":
            suggest = "tcp_keepalive"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connect_timeout: Optional[str] = None,
                 max_connections: Optional[int] = None,
                 tcp_keepalive: Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive'] = None):
        """
        Settings common to both HTTP and TCP upstream connections.
        :param str connect_timeout: TCP connection timeout.
        :param int max_connections: Maximum number of HTTP1 /TCP connections to a destination host.
        :param 'DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepaliveArgs' tcp_keepalive: If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        if connect_timeout is not None:
            pulumi.set(__self__, "connect_timeout", connect_timeout)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if tcp_keepalive is not None:
            pulumi.set(__self__, "tcp_keepalive", tcp_keepalive)

    @property
    @pulumi.getter(name="connectTimeout")
    def connect_timeout(self) -> Optional[str]:
        """
        TCP connection timeout.
        """
        return pulumi.get(self, "connect_timeout")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        Maximum number of HTTP1 /TCP connections to a destination host.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter(name="tcpKeepalive")
    def tcp_keepalive(self) -> Optional['outputs.DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive']:
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        """
        return pulumi.get(self, "tcp_keepalive")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsConnectionPoolTcpTcpKeepalive(dict):
    """
    If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
    """
    def __init__(__self__, *,
                 interval: Optional[str] = None,
                 probes: Optional[int] = None,
                 time: Optional[str] = None):
        """
        If set then set SO_KEEPALIVE on the socket to enable TCP Keepalives.
        :param str interval: The time duration between keep-alive probes.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if probes is not None:
            pulumi.set(__self__, "probes", probes)
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        """
        The time duration between keep-alive probes.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter
    def probes(self) -> Optional[int]:
        return pulumi.get(self, "probes")

    @property
    @pulumi.getter
    def time(self) -> Optional[str]:
        return pulumi.get(self, "time")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseEjectionTime":
            suggest = "base_ejection_time"
        elif key == "consecutive5xxErrors":
            suggest = "consecutive5xx_errors"
        elif key == "consecutiveErrors":
            suggest = "consecutive_errors"
        elif key == "consecutiveGatewayErrors":
            suggest = "consecutive_gateway_errors"
        elif key == "consecutiveLocalOriginFailures":
            suggest = "consecutive_local_origin_failures"
        elif key == "maxEjectionPercent":
            suggest = "max_ejection_percent"
        elif key == "minHealthPercent":
            suggest = "min_health_percent"
        elif key == "splitExternalLocalOriginErrors":
            suggest = "split_external_local_origin_errors"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecTrafficPolicyPortLevelSettingsOutlierDetection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_ejection_time: Optional[str] = None,
                 consecutive5xx_errors: Optional[int] = None,
                 consecutive_errors: Optional[int] = None,
                 consecutive_gateway_errors: Optional[int] = None,
                 consecutive_local_origin_failures: Optional[int] = None,
                 interval: Optional[str] = None,
                 max_ejection_percent: Optional[int] = None,
                 min_health_percent: Optional[int] = None,
                 split_external_local_origin_errors: Optional[bool] = None):
        """
        :param str base_ejection_time: Minimum ejection duration.
        :param int consecutive5xx_errors: Number of 5xx errors before a host is ejected from the connection pool.
        :param int consecutive_gateway_errors: Number of gateway errors before a host is ejected from the connection pool.
        :param str interval: Time interval between ejection sweep analysis.
        :param bool split_external_local_origin_errors: Determines whether to distinguish local origin failures from external errors.
        """
        if base_ejection_time is not None:
            pulumi.set(__self__, "base_ejection_time", base_ejection_time)
        if consecutive5xx_errors is not None:
            pulumi.set(__self__, "consecutive5xx_errors", consecutive5xx_errors)
        if consecutive_errors is not None:
            pulumi.set(__self__, "consecutive_errors", consecutive_errors)
        if consecutive_gateway_errors is not None:
            pulumi.set(__self__, "consecutive_gateway_errors", consecutive_gateway_errors)
        if consecutive_local_origin_failures is not None:
            pulumi.set(__self__, "consecutive_local_origin_failures", consecutive_local_origin_failures)
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if max_ejection_percent is not None:
            pulumi.set(__self__, "max_ejection_percent", max_ejection_percent)
        if min_health_percent is not None:
            pulumi.set(__self__, "min_health_percent", min_health_percent)
        if split_external_local_origin_errors is not None:
            pulumi.set(__self__, "split_external_local_origin_errors", split_external_local_origin_errors)

    @property
    @pulumi.getter(name="baseEjectionTime")
    def base_ejection_time(self) -> Optional[str]:
        """
        Minimum ejection duration.
        """
        return pulumi.get(self, "base_ejection_time")

    @property
    @pulumi.getter(name="consecutive5xxErrors")
    def consecutive5xx_errors(self) -> Optional[int]:
        """
        Number of 5xx errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive5xx_errors")

    @property
    @pulumi.getter(name="consecutiveErrors")
    def consecutive_errors(self) -> Optional[int]:
        return pulumi.get(self, "consecutive_errors")

    @property
    @pulumi.getter(name="consecutiveGatewayErrors")
    def consecutive_gateway_errors(self) -> Optional[int]:
        """
        Number of gateway errors before a host is ejected from the connection pool.
        """
        return pulumi.get(self, "consecutive_gateway_errors")

    @property
    @pulumi.getter(name="consecutiveLocalOriginFailures")
    def consecutive_local_origin_failures(self) -> Optional[int]:
        return pulumi.get(self, "consecutive_local_origin_failures")

    @property
    @pulumi.getter
    def interval(self) -> Optional[str]:
        """
        Time interval between ejection sweep analysis.
        """
        return pulumi.get(self, "interval")

    @property
    @pulumi.getter(name="maxEjectionPercent")
    def max_ejection_percent(self) -> Optional[int]:
        return pulumi.get(self, "max_ejection_percent")

    @property
    @pulumi.getter(name="minHealthPercent")
    def min_health_percent(self) -> Optional[int]:
        return pulumi.get(self, "min_health_percent")

    @property
    @pulumi.getter(name="splitExternalLocalOriginErrors")
    def split_external_local_origin_errors(self) -> Optional[bool]:
        """
        Determines whether to distinguish local origin failures from external errors.
        """
        return pulumi.get(self, "split_external_local_origin_errors")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsPort(dict):
    def __init__(__self__, *,
                 number: Optional[int] = None):
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        return pulumi.get(self, "number")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyPortLevelSettingsTls(dict):
    """
    TLS related settings for connections to the upstream service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificates":
            suggest = "ca_certificates"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "credentialName":
            suggest = "credential_name"
        elif key == "insecureSkipVerify":
            suggest = "insecure_skip_verify"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "subjectAltNames":
            suggest = "subject_alt_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecTrafficPolicyPortLevelSettingsTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecTrafficPolicyPortLevelSettingsTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecTrafficPolicyPortLevelSettingsTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificates: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 credential_name: Optional[str] = None,
                 insecure_skip_verify: Optional[bool] = None,
                 mode: Optional[str] = None,
                 private_key: Optional[str] = None,
                 sni: Optional[str] = None,
                 subject_alt_names: Optional[Sequence[str]] = None):
        """
        TLS related settings for connections to the upstream service.
        :param str client_certificate: REQUIRED if mode is `MUTUAL`.
        :param str private_key: REQUIRED if mode is `MUTUAL`.
        :param str sni: SNI string to present to the server during TLS handshake.
        """
        if ca_certificates is not None:
            pulumi.set(__self__, "ca_certificates", ca_certificates)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter(name="caCertificates")
    def ca_certificates(self) -> Optional[str]:
        return pulumi.get(self, "ca_certificates")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[str]:
        return pulumi.get(self, "credential_name")

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[bool]:
        return pulumi.get(self, "insecure_skip_verify")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def sni(self) -> Optional[str]:
        """
        SNI string to present to the server during TLS handshake.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class DestinationRuleSpecTrafficPolicyTls(dict):
    """
    TLS related settings for connections to the upstream service.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificates":
            suggest = "ca_certificates"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "credentialName":
            suggest = "credential_name"
        elif key == "insecureSkipVerify":
            suggest = "insecure_skip_verify"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "subjectAltNames":
            suggest = "subject_alt_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DestinationRuleSpecTrafficPolicyTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DestinationRuleSpecTrafficPolicyTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DestinationRuleSpecTrafficPolicyTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificates: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 credential_name: Optional[str] = None,
                 insecure_skip_verify: Optional[bool] = None,
                 mode: Optional[str] = None,
                 private_key: Optional[str] = None,
                 sni: Optional[str] = None,
                 subject_alt_names: Optional[Sequence[str]] = None):
        """
        TLS related settings for connections to the upstream service.
        :param str client_certificate: REQUIRED if mode is `MUTUAL`.
        :param str private_key: REQUIRED if mode is `MUTUAL`.
        :param str sni: SNI string to present to the server during TLS handshake.
        """
        if ca_certificates is not None:
            pulumi.set(__self__, "ca_certificates", ca_certificates)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if insecure_skip_verify is not None:
            pulumi.set(__self__, "insecure_skip_verify", insecure_skip_verify)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if sni is not None:
            pulumi.set(__self__, "sni", sni)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)

    @property
    @pulumi.getter(name="caCertificates")
    def ca_certificates(self) -> Optional[str]:
        return pulumi.get(self, "ca_certificates")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[str]:
        return pulumi.get(self, "credential_name")

    @property
    @pulumi.getter(name="insecureSkipVerify")
    def insecure_skip_verify(self) -> Optional[bool]:
        return pulumi.get(self, "insecure_skip_verify")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter
    def sni(self) -> Optional[str]:
        """
        SNI string to present to the server during TLS handshake.
        """
        return pulumi.get(self, "sni")

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subject_alt_names")


@pulumi.output_type
class GatewaySpec(dict):
    """
    Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
    """
    def __init__(__self__, *,
                 selector: Optional[Mapping[str, str]] = None,
                 servers: Optional[Sequence['outputs.GatewaySpecServers']] = None):
        """
        Configuration affecting edge load balancer. See more details at: https://istio.io/docs/reference/config/networking/gateway.html
        :param Sequence['GatewaySpecServersArgs'] servers: A list of server specifications.
        """
        if selector is not None:
            pulumi.set(__self__, "selector", selector)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @property
    @pulumi.getter
    def selector(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "selector")

    @property
    @pulumi.getter
    def servers(self) -> Optional[Sequence['outputs.GatewaySpecServers']]:
        """
        A list of server specifications.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class GatewaySpecServers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultEndpoint":
            suggest = "default_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecServers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecServers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecServers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind: Optional[str] = None,
                 default_endpoint: Optional[str] = None,
                 hosts: Optional[Sequence[str]] = None,
                 name: Optional[str] = None,
                 port: Optional['outputs.GatewaySpecServersPort'] = None,
                 tls: Optional['outputs.GatewaySpecServersTls'] = None):
        """
        :param Sequence[str] hosts: One or more hosts exposed by this gateway.
        :param str name: An optional name of the server, when set must be unique across all servers.
        :param 'GatewaySpecServersTlsArgs' tls: Set of TLS related options that govern the server's behavior.
        """
        if bind is not None:
            pulumi.set(__self__, "bind", bind)
        if default_endpoint is not None:
            pulumi.set(__self__, "default_endpoint", default_endpoint)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter
    def bind(self) -> Optional[str]:
        return pulumi.get(self, "bind")

    @property
    @pulumi.getter(name="defaultEndpoint")
    def default_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "default_endpoint")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        """
        One or more hosts exposed by this gateway.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        An optional name of the server, when set must be unique across all servers.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional['outputs.GatewaySpecServersPort']:
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def tls(self) -> Optional['outputs.GatewaySpecServersTls']:
        """
        Set of TLS related options that govern the server's behavior.
        """
        return pulumi.get(self, "tls")


@pulumi.output_type
class GatewaySpecServersPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecServersPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecServersPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecServersPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 number: Optional[int] = None,
                 protocol: Optional[str] = None,
                 target_port: Optional[int] = None):
        """
        :param str name: Label assigned to the port.
        :param int number: A valid non-negative integer port number.
        :param str protocol: The protocol exposed on the port.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Label assigned to the port.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        """
        A valid non-negative integer port number.
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol exposed on the port.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[int]:
        return pulumi.get(self, "target_port")


@pulumi.output_type
class GatewaySpecServersTls(dict):
    """
    Set of TLS related options that govern the server's behavior.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificates":
            suggest = "ca_certificates"
        elif key == "cipherSuites":
            suggest = "cipher_suites"
        elif key == "credentialName":
            suggest = "credential_name"
        elif key == "httpsRedirect":
            suggest = "https_redirect"
        elif key == "maxProtocolVersion":
            suggest = "max_protocol_version"
        elif key == "minProtocolVersion":
            suggest = "min_protocol_version"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "serverCertificate":
            suggest = "server_certificate"
        elif key == "subjectAltNames":
            suggest = "subject_alt_names"
        elif key == "verifyCertificateHash":
            suggest = "verify_certificate_hash"
        elif key == "verifyCertificateSpki":
            suggest = "verify_certificate_spki"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GatewaySpecServersTls. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GatewaySpecServersTls.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GatewaySpecServersTls.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificates: Optional[str] = None,
                 cipher_suites: Optional[Sequence[str]] = None,
                 credential_name: Optional[str] = None,
                 https_redirect: Optional[bool] = None,
                 max_protocol_version: Optional[str] = None,
                 min_protocol_version: Optional[str] = None,
                 mode: Optional[str] = None,
                 private_key: Optional[str] = None,
                 server_certificate: Optional[str] = None,
                 subject_alt_names: Optional[Sequence[str]] = None,
                 verify_certificate_hash: Optional[Sequence[str]] = None,
                 verify_certificate_spki: Optional[Sequence[str]] = None):
        """
        Set of TLS related options that govern the server's behavior.
        :param str ca_certificates: REQUIRED if mode is `MUTUAL`.
        :param Sequence[str] cipher_suites: Optional: If specified, only support the specified cipher list.
        :param str max_protocol_version: Optional: Maximum TLS protocol version.
        :param str min_protocol_version: Optional: Minimum TLS protocol version.
        :param str private_key: REQUIRED if mode is `SIMPLE` or `MUTUAL`.
        :param str server_certificate: REQUIRED if mode is `SIMPLE` or `MUTUAL`.
        """
        if ca_certificates is not None:
            pulumi.set(__self__, "ca_certificates", ca_certificates)
        if cipher_suites is not None:
            pulumi.set(__self__, "cipher_suites", cipher_suites)
        if credential_name is not None:
            pulumi.set(__self__, "credential_name", credential_name)
        if https_redirect is not None:
            pulumi.set(__self__, "https_redirect", https_redirect)
        if max_protocol_version is not None:
            pulumi.set(__self__, "max_protocol_version", max_protocol_version)
        if min_protocol_version is not None:
            pulumi.set(__self__, "min_protocol_version", min_protocol_version)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if server_certificate is not None:
            pulumi.set(__self__, "server_certificate", server_certificate)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)
        if verify_certificate_hash is not None:
            pulumi.set(__self__, "verify_certificate_hash", verify_certificate_hash)
        if verify_certificate_spki is not None:
            pulumi.set(__self__, "verify_certificate_spki", verify_certificate_spki)

    @property
    @pulumi.getter(name="caCertificates")
    def ca_certificates(self) -> Optional[str]:
        """
        REQUIRED if mode is `MUTUAL`.
        """
        return pulumi.get(self, "ca_certificates")

    @property
    @pulumi.getter(name="cipherSuites")
    def cipher_suites(self) -> Optional[Sequence[str]]:
        """
        Optional: If specified, only support the specified cipher list.
        """
        return pulumi.get(self, "cipher_suites")

    @property
    @pulumi.getter(name="credentialName")
    def credential_name(self) -> Optional[str]:
        return pulumi.get(self, "credential_name")

    @property
    @pulumi.getter(name="httpsRedirect")
    def https_redirect(self) -> Optional[bool]:
        return pulumi.get(self, "https_redirect")

    @property
    @pulumi.getter(name="maxProtocolVersion")
    def max_protocol_version(self) -> Optional[str]:
        """
        Optional: Maximum TLS protocol version.
        """
        return pulumi.get(self, "max_protocol_version")

    @property
    @pulumi.getter(name="minProtocolVersion")
    def min_protocol_version(self) -> Optional[str]:
        """
        Optional: Minimum TLS protocol version.
        """
        return pulumi.get(self, "min_protocol_version")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        REQUIRED if mode is `SIMPLE` or `MUTUAL`.
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="serverCertificate")
    def server_certificate(self) -> Optional[str]:
        """
        REQUIRED if mode is `SIMPLE` or `MUTUAL`.
        """
        return pulumi.get(self, "server_certificate")

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subject_alt_names")

    @property
    @pulumi.getter(name="verifyCertificateHash")
    def verify_certificate_hash(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "verify_certificate_hash")

    @property
    @pulumi.getter(name="verifyCertificateSpki")
    def verify_certificate_spki(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "verify_certificate_spki")


@pulumi.output_type
class ProxyConfigSpec(dict):
    """
    Provides configuration for individual workloads. See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentVariables":
            suggest = "environment_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyConfigSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyConfigSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyConfigSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 concurrency: Optional[int] = None,
                 environment_variables: Optional[Mapping[str, str]] = None,
                 image: Optional['outputs.ProxyConfigSpecImage'] = None,
                 selector: Optional['outputs.ProxyConfigSpecSelector'] = None):
        """
        Provides configuration for individual workloads. See more details at: https://istio.io/docs/reference/config/networking/proxy-config.html
        :param int concurrency: The number of worker threads to run.
        :param Mapping[str, str] environment_variables: Additional environment variables for the proxy.
        :param 'ProxyConfigSpecImageArgs' image: Specifies the details of the proxy image.
        :param 'ProxyConfigSpecSelectorArgs' selector: Optional.
        """
        if concurrency is not None:
            pulumi.set(__self__, "concurrency", concurrency)
        if environment_variables is not None:
            pulumi.set(__self__, "environment_variables", environment_variables)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if selector is not None:
            pulumi.set(__self__, "selector", selector)

    @property
    @pulumi.getter
    def concurrency(self) -> Optional[int]:
        """
        The number of worker threads to run.
        """
        return pulumi.get(self, "concurrency")

    @property
    @pulumi.getter(name="environmentVariables")
    def environment_variables(self) -> Optional[Mapping[str, str]]:
        """
        Additional environment variables for the proxy.
        """
        return pulumi.get(self, "environment_variables")

    @property
    @pulumi.getter
    def image(self) -> Optional['outputs.ProxyConfigSpecImage']:
        """
        Specifies the details of the proxy image.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def selector(self) -> Optional['outputs.ProxyConfigSpecSelector']:
        """
        Optional.
        """
        return pulumi.get(self, "selector")


@pulumi.output_type
class ProxyConfigSpecImage(dict):
    """
    Specifies the details of the proxy image.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageType":
            suggest = "image_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyConfigSpecImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyConfigSpecImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyConfigSpecImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_type: Optional[str] = None):
        """
        Specifies the details of the proxy image.
        :param str image_type: The image type of the image.
        """
        if image_type is not None:
            pulumi.set(__self__, "image_type", image_type)

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> Optional[str]:
        """
        The image type of the image.
        """
        return pulumi.get(self, "image_type")


@pulumi.output_type
class ProxyConfigSpecSelector(dict):
    """
    Optional.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchLabels":
            suggest = "match_labels"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyConfigSpecSelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyConfigSpecSelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyConfigSpecSelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_labels: Optional[Mapping[str, str]] = None):
        """
        Optional.
        """
        if match_labels is not None:
            pulumi.set(__self__, "match_labels", match_labels)

    @property
    @pulumi.getter(name="matchLabels")
    def match_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "match_labels")


@pulumi.output_type
class ServiceEntrySpec(dict):
    """
    Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportTo":
            suggest = "export_to"
        elif key == "subjectAltNames":
            suggest = "subject_alt_names"
        elif key == "workloadSelector":
            suggest = "workload_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEntrySpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEntrySpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEntrySpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Optional[Sequence[str]] = None,
                 endpoints: Optional[Sequence['outputs.ServiceEntrySpecEndpoints']] = None,
                 export_to: Optional[Sequence[str]] = None,
                 hosts: Optional[Sequence[str]] = None,
                 location: Optional[str] = None,
                 ports: Optional[Sequence['outputs.ServiceEntrySpecPorts']] = None,
                 resolution: Optional[str] = None,
                 subject_alt_names: Optional[Sequence[str]] = None,
                 workload_selector: Optional['outputs.ServiceEntrySpecWorkloadSelector'] = None):
        """
        Configuration affecting service registry. See more details at: https://istio.io/docs/reference/config/networking/service-entry.html
        :param Sequence[str] addresses: The virtual IP addresses associated with the service.
        :param Sequence['ServiceEntrySpecEndpointsArgs'] endpoints: One or more endpoints associated with the service.
        :param Sequence[str] export_to: A list of namespaces to which this service is exported.
        :param Sequence[str] hosts: The hosts associated with the ServiceEntry.
        :param Sequence['ServiceEntrySpecPortsArgs'] ports: The ports associated with the external service.
        :param str resolution: Service discovery mode for the hosts.
        :param 'ServiceEntrySpecWorkloadSelectorArgs' workload_selector: Applicable only for MESH_INTERNAL services.
        """
        if addresses is not None:
            pulumi.set(__self__, "addresses", addresses)
        if endpoints is not None:
            pulumi.set(__self__, "endpoints", endpoints)
        if export_to is not None:
            pulumi.set(__self__, "export_to", export_to)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if resolution is not None:
            pulumi.set(__self__, "resolution", resolution)
        if subject_alt_names is not None:
            pulumi.set(__self__, "subject_alt_names", subject_alt_names)
        if workload_selector is not None:
            pulumi.set(__self__, "workload_selector", workload_selector)

    @property
    @pulumi.getter
    def addresses(self) -> Optional[Sequence[str]]:
        """
        The virtual IP addresses associated with the service.
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def endpoints(self) -> Optional[Sequence['outputs.ServiceEntrySpecEndpoints']]:
        """
        One or more endpoints associated with the service.
        """
        return pulumi.get(self, "endpoints")

    @property
    @pulumi.getter(name="exportTo")
    def export_to(self) -> Optional[Sequence[str]]:
        """
        A list of namespaces to which this service is exported.
        """
        return pulumi.get(self, "export_to")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        """
        The hosts associated with the ServiceEntry.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Sequence['outputs.ServiceEntrySpecPorts']]:
        """
        The ports associated with the external service.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def resolution(self) -> Optional[str]:
        """
        Service discovery mode for the hosts.
        """
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter(name="subjectAltNames")
    def subject_alt_names(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "subject_alt_names")

    @property
    @pulumi.getter(name="workloadSelector")
    def workload_selector(self) -> Optional['outputs.ServiceEntrySpecWorkloadSelector']:
        """
        Applicable only for MESH_INTERNAL services.
        """
        return pulumi.get(self, "workload_selector")


@pulumi.output_type
class ServiceEntrySpecEndpoints(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEntrySpecEndpoints. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEntrySpecEndpoints.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEntrySpecEndpoints.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 locality: Optional[str] = None,
                 network: Optional[str] = None,
                 ports: Optional[Mapping[str, int]] = None,
                 service_account: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param Mapping[str, str] labels: One or more labels associated with the endpoint.
        :param str locality: The locality associated with the endpoint.
        :param Mapping[str, int] ports: Set of ports associated with the endpoint.
        :param int weight: The load balancing weight associated with the endpoint.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        One or more labels associated with the endpoint.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def locality(self) -> Optional[str]:
        """
        The locality associated with the endpoint.
        """
        return pulumi.get(self, "locality")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Mapping[str, int]]:
        """
        Set of ports associated with the endpoint.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[str]:
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        The load balancing weight associated with the endpoint.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class ServiceEntrySpecPorts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceEntrySpecPorts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceEntrySpecPorts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceEntrySpecPorts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 number: Optional[int] = None,
                 protocol: Optional[str] = None,
                 target_port: Optional[int] = None):
        """
        :param str name: Label assigned to the port.
        :param int number: A valid non-negative integer port number.
        :param str protocol: The protocol exposed on the port.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Label assigned to the port.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        """
        A valid non-negative integer port number.
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol exposed on the port.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[int]:
        return pulumi.get(self, "target_port")


@pulumi.output_type
class ServiceEntrySpecWorkloadSelector(dict):
    """
    Applicable only for MESH_INTERNAL services.
    """
    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None):
        """
        Applicable only for MESH_INTERNAL services.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")


@pulumi.output_type
class SidecarSpec(dict):
    """
    Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "outboundTrafficPolicy":
            suggest = "outbound_traffic_policy"
        elif key == "workloadSelector":
            suggest = "workload_selector"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SidecarSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SidecarSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SidecarSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 egress: Optional[Sequence['outputs.SidecarSpecEgress']] = None,
                 ingress: Optional[Sequence['outputs.SidecarSpecIngress']] = None,
                 outbound_traffic_policy: Optional['outputs.SidecarSpecOutboundTrafficPolicy'] = None,
                 workload_selector: Optional['outputs.SidecarSpecWorkloadSelector'] = None):
        """
        Configuration affecting network reachability of a sidecar. See more details at: https://istio.io/docs/reference/config/networking/sidecar.html
        :param 'SidecarSpecOutboundTrafficPolicyArgs' outbound_traffic_policy: Configuration for the outbound traffic policy.
        """
        if egress is not None:
            pulumi.set(__self__, "egress", egress)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if outbound_traffic_policy is not None:
            pulumi.set(__self__, "outbound_traffic_policy", outbound_traffic_policy)
        if workload_selector is not None:
            pulumi.set(__self__, "workload_selector", workload_selector)

    @property
    @pulumi.getter
    def egress(self) -> Optional[Sequence['outputs.SidecarSpecEgress']]:
        return pulumi.get(self, "egress")

    @property
    @pulumi.getter
    def ingress(self) -> Optional[Sequence['outputs.SidecarSpecIngress']]:
        return pulumi.get(self, "ingress")

    @property
    @pulumi.getter(name="outboundTrafficPolicy")
    def outbound_traffic_policy(self) -> Optional['outputs.SidecarSpecOutboundTrafficPolicy']:
        """
        Configuration for the outbound traffic policy.
        """
        return pulumi.get(self, "outbound_traffic_policy")

    @property
    @pulumi.getter(name="workloadSelector")
    def workload_selector(self) -> Optional['outputs.SidecarSpecWorkloadSelector']:
        return pulumi.get(self, "workload_selector")


@pulumi.output_type
class SidecarSpecEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captureMode":
            suggest = "capture_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SidecarSpecEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SidecarSpecEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SidecarSpecEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind: Optional[str] = None,
                 capture_mode: Optional[str] = None,
                 hosts: Optional[Sequence[str]] = None,
                 port: Optional['outputs.SidecarSpecEgressPort'] = None):
        """
        :param 'SidecarSpecEgressPortArgs' port: The port associated with the listener.
        """
        if bind is not None:
            pulumi.set(__self__, "bind", bind)
        if capture_mode is not None:
            pulumi.set(__self__, "capture_mode", capture_mode)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def bind(self) -> Optional[str]:
        return pulumi.get(self, "bind")

    @property
    @pulumi.getter(name="captureMode")
    def capture_mode(self) -> Optional[str]:
        return pulumi.get(self, "capture_mode")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def port(self) -> Optional['outputs.SidecarSpecEgressPort']:
        """
        The port associated with the listener.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class SidecarSpecEgressPort(dict):
    """
    The port associated with the listener.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SidecarSpecEgressPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SidecarSpecEgressPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SidecarSpecEgressPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 number: Optional[int] = None,
                 protocol: Optional[str] = None,
                 target_port: Optional[int] = None):
        """
        The port associated with the listener.
        :param str name: Label assigned to the port.
        :param int number: A valid non-negative integer port number.
        :param str protocol: The protocol exposed on the port.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Label assigned to the port.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        """
        A valid non-negative integer port number.
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol exposed on the port.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[int]:
        return pulumi.get(self, "target_port")


@pulumi.output_type
class SidecarSpecIngress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "captureMode":
            suggest = "capture_mode"
        elif key == "defaultEndpoint":
            suggest = "default_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SidecarSpecIngress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SidecarSpecIngress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SidecarSpecIngress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bind: Optional[str] = None,
                 capture_mode: Optional[str] = None,
                 default_endpoint: Optional[str] = None,
                 port: Optional['outputs.SidecarSpecIngressPort'] = None):
        """
        :param str bind: The IP to which the listener should be bound.
        :param 'SidecarSpecIngressPortArgs' port: The port associated with the listener.
        """
        if bind is not None:
            pulumi.set(__self__, "bind", bind)
        if capture_mode is not None:
            pulumi.set(__self__, "capture_mode", capture_mode)
        if default_endpoint is not None:
            pulumi.set(__self__, "default_endpoint", default_endpoint)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def bind(self) -> Optional[str]:
        """
        The IP to which the listener should be bound.
        """
        return pulumi.get(self, "bind")

    @property
    @pulumi.getter(name="captureMode")
    def capture_mode(self) -> Optional[str]:
        return pulumi.get(self, "capture_mode")

    @property
    @pulumi.getter(name="defaultEndpoint")
    def default_endpoint(self) -> Optional[str]:
        return pulumi.get(self, "default_endpoint")

    @property
    @pulumi.getter
    def port(self) -> Optional['outputs.SidecarSpecIngressPort']:
        """
        The port associated with the listener.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class SidecarSpecIngressPort(dict):
    """
    The port associated with the listener.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPort":
            suggest = "target_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SidecarSpecIngressPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SidecarSpecIngressPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SidecarSpecIngressPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 number: Optional[int] = None,
                 protocol: Optional[str] = None,
                 target_port: Optional[int] = None):
        """
        The port associated with the listener.
        :param str name: Label assigned to the port.
        :param int number: A valid non-negative integer port number.
        :param str protocol: The protocol exposed on the port.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if target_port is not None:
            pulumi.set(__self__, "target_port", target_port)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Label assigned to the port.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        """
        A valid non-negative integer port number.
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        The protocol exposed on the port.
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> Optional[int]:
        return pulumi.get(self, "target_port")


@pulumi.output_type
class SidecarSpecOutboundTrafficPolicy(dict):
    """
    Configuration for the outbound traffic policy.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "egressProxy":
            suggest = "egress_proxy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SidecarSpecOutboundTrafficPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SidecarSpecOutboundTrafficPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SidecarSpecOutboundTrafficPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 egress_proxy: Optional['outputs.SidecarSpecOutboundTrafficPolicyEgressProxy'] = None,
                 mode: Optional[str] = None):
        """
        Configuration for the outbound traffic policy.
        """
        if egress_proxy is not None:
            pulumi.set(__self__, "egress_proxy", egress_proxy)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)

    @property
    @pulumi.getter(name="egressProxy")
    def egress_proxy(self) -> Optional['outputs.SidecarSpecOutboundTrafficPolicyEgressProxy']:
        return pulumi.get(self, "egress_proxy")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        return pulumi.get(self, "mode")


@pulumi.output_type
class SidecarSpecOutboundTrafficPolicyEgressProxy(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional['outputs.SidecarSpecOutboundTrafficPolicyEgressProxyPort'] = None,
                 subset: Optional[str] = None):
        """
        :param str host: The name of a service from the service registry.
        :param 'SidecarSpecOutboundTrafficPolicyEgressProxyPortArgs' port: Specifies the port on the host that is being addressed.
        :param str subset: The name of a subset within the service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subset is not None:
            pulumi.set(__self__, "subset", subset)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional['outputs.SidecarSpecOutboundTrafficPolicyEgressProxyPort']:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def subset(self) -> Optional[str]:
        """
        The name of a subset within the service.
        """
        return pulumi.get(self, "subset")


@pulumi.output_type
class SidecarSpecOutboundTrafficPolicyEgressProxyPort(dict):
    """
    Specifies the port on the host that is being addressed.
    """
    def __init__(__self__, *,
                 number: Optional[int] = None):
        """
        Specifies the port on the host that is being addressed.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        return pulumi.get(self, "number")


@pulumi.output_type
class SidecarSpecWorkloadSelector(dict):
    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None):
        if labels is not None:
            pulumi.set(__self__, "labels", labels)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "labels")


@pulumi.output_type
class VirtualServiceSpec(dict):
    """
    Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exportTo":
            suggest = "export_to"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualServiceSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualServiceSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualServiceSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 export_to: Optional[Sequence[str]] = None,
                 gateways: Optional[Sequence[str]] = None,
                 hosts: Optional[Sequence[str]] = None,
                 http: Optional[Sequence['outputs.VirtualServiceSpecHttp']] = None,
                 tcp: Optional[Sequence['outputs.VirtualServiceSpecTcp']] = None,
                 tls: Optional[Sequence['outputs.VirtualServiceSpecTls']] = None):
        """
        Configuration affecting label/content routing, sni routing, etc. See more details at: https://istio.io/docs/reference/config/networking/virtual-service.html
        :param Sequence[str] export_to: A list of namespaces to which this virtual service is exported.
        :param Sequence[str] gateways: The names of gateways and sidecars that should apply these routes.
        :param Sequence[str] hosts: The destination hosts to which traffic is being sent.
        :param Sequence['VirtualServiceSpecHttpArgs'] http: An ordered list of route rules for HTTP traffic.
        :param Sequence['VirtualServiceSpecTcpArgs'] tcp: An ordered list of route rules for opaque TCP traffic.
        """
        if export_to is not None:
            pulumi.set(__self__, "export_to", export_to)
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if http is not None:
            pulumi.set(__self__, "http", http)
        if tcp is not None:
            pulumi.set(__self__, "tcp", tcp)
        if tls is not None:
            pulumi.set(__self__, "tls", tls)

    @property
    @pulumi.getter(name="exportTo")
    def export_to(self) -> Optional[Sequence[str]]:
        """
        A list of namespaces to which this virtual service is exported.
        """
        return pulumi.get(self, "export_to")

    @property
    @pulumi.getter
    def gateways(self) -> Optional[Sequence[str]]:
        """
        The names of gateways and sidecars that should apply these routes.
        """
        return pulumi.get(self, "gateways")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence[str]]:
        """
        The destination hosts to which traffic is being sent.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def http(self) -> Optional[Sequence['outputs.VirtualServiceSpecHttp']]:
        """
        An ordered list of route rules for HTTP traffic.
        """
        return pulumi.get(self, "http")

    @property
    @pulumi.getter
    def tcp(self) -> Optional[Sequence['outputs.VirtualServiceSpecTcp']]:
        """
        An ordered list of route rules for opaque TCP traffic.
        """
        return pulumi.get(self, "tcp")

    @property
    @pulumi.getter
    def tls(self) -> Optional[Sequence['outputs.VirtualServiceSpecTls']]:
        return pulumi.get(self, "tls")


@pulumi.output_type
class VirtualServiceSpecHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "corsPolicy":
            suggest = "cors_policy"
        elif key == "mirrorPercent":
            suggest = "mirror_percent"
        elif key == "mirrorPercentage":
            suggest = "mirror_percentage"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualServiceSpecHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualServiceSpecHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualServiceSpecHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cors_policy: Optional['outputs.VirtualServiceSpecHttpCorsPolicy'] = None,
                 delegate: Optional['outputs.VirtualServiceSpecHttpDelegate'] = None,
                 fault: Optional['outputs.VirtualServiceSpecHttpFault'] = None,
                 headers: Optional['outputs.VirtualServiceSpecHttpHeaders'] = None,
                 match: Optional[Sequence['outputs.VirtualServiceSpecHttpMatch']] = None,
                 mirror: Optional['outputs.VirtualServiceSpecHttpMirror'] = None,
                 mirror_percent: Optional[int] = None,
                 mirror_percentage: Optional['outputs.VirtualServiceSpecHttpMirrorPercentage'] = None,
                 mirror_percent: Optional[int] = None,
                 name: Optional[str] = None,
                 redirect: Optional[Any] = None,
                 retries: Optional['outputs.VirtualServiceSpecHttpRetries'] = None,
                 rewrite: Optional['outputs.VirtualServiceSpecHttpRewrite'] = None,
                 route: Optional[Sequence['outputs.VirtualServiceSpecHttpRoute']] = None,
                 timeout: Optional[str] = None):
        """
        :param 'VirtualServiceSpecHttpCorsPolicyArgs' cors_policy: Cross-Origin Resource Sharing policy (CORS).
        :param 'VirtualServiceSpecHttpFaultArgs' fault: Fault injection policy to apply on HTTP traffic at the client side.
        :param int mirror_percent: Percentage of the traffic to be mirrored by the `mirror` field.
        :param 'VirtualServiceSpecHttpMirrorPercentageArgs' mirror_percentage: Percentage of the traffic to be mirrored by the `mirror` field.
        :param int mirror_percent: Percentage of the traffic to be mirrored by the `mirror` field.
        :param str name: The name assigned to the route for debugging purposes.
        :param Any redirect: A HTTP rule can either redirect or forward (default) traffic.
        :param 'VirtualServiceSpecHttpRetriesArgs' retries: Retry policy for HTTP requests.
        :param 'VirtualServiceSpecHttpRewriteArgs' rewrite: Rewrite HTTP URIs and Authority headers.
        :param Sequence['VirtualServiceSpecHttpRouteArgs'] route: A HTTP rule can either redirect or forward (default) traffic.
        :param str timeout: Timeout for HTTP requests, default is disabled.
        """
        if cors_policy is not None:
            pulumi.set(__self__, "cors_policy", cors_policy)
        if delegate is not None:
            pulumi.set(__self__, "delegate", delegate)
        if fault is not None:
            pulumi.set(__self__, "fault", fault)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if mirror is not None:
            pulumi.set(__self__, "mirror", mirror)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)
        if mirror_percentage is not None:
            pulumi.set(__self__, "mirror_percentage", mirror_percentage)
        if mirror_percent is not None:
            pulumi.set(__self__, "mirror_percent", mirror_percent)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)
        if retries is not None:
            pulumi.set(__self__, "retries", retries)
        if rewrite is not None:
            pulumi.set(__self__, "rewrite", rewrite)
        if route is not None:
            pulumi.set(__self__, "route", route)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter(name="corsPolicy")
    def cors_policy(self) -> Optional['outputs.VirtualServiceSpecHttpCorsPolicy']:
        """
        Cross-Origin Resource Sharing policy (CORS).
        """
        return pulumi.get(self, "cors_policy")

    @property
    @pulumi.getter
    def delegate(self) -> Optional['outputs.VirtualServiceSpecHttpDelegate']:
        return pulumi.get(self, "delegate")

    @property
    @pulumi.getter
    def fault(self) -> Optional['outputs.VirtualServiceSpecHttpFault']:
        """
        Fault injection policy to apply on HTTP traffic at the client side.
        """
        return pulumi.get(self, "fault")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.VirtualServiceSpecHttpHeaders']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def match(self) -> Optional[Sequence['outputs.VirtualServiceSpecHttpMatch']]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def mirror(self) -> Optional['outputs.VirtualServiceSpecHttpMirror']:
        return pulumi.get(self, "mirror")

    @property
    @pulumi.getter(name="mirrorPercent")
    def mirror_percent(self) -> Optional[int]:
        """
        Percentage of the traffic to be mirrored by the `mirror` field.
        """
        return pulumi.get(self, "mirror_percent")

    @property
    @pulumi.getter(name="mirrorPercentage")
    def mirror_percentage(self) -> Optional['outputs.VirtualServiceSpecHttpMirrorPercentage']:
        """
        Percentage of the traffic to be mirrored by the `mirror` field.
        """
        return pulumi.get(self, "mirror_percentage")

    @property
    @pulumi.getter
    def mirror_percent(self) -> Optional[int]:
        """
        Percentage of the traffic to be mirrored by the `mirror` field.
        """
        return pulumi.get(self, "mirror_percent")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name assigned to the route for debugging purposes.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def redirect(self) -> Optional[Any]:
        """
        A HTTP rule can either redirect or forward (default) traffic.
        """
        return pulumi.get(self, "redirect")

    @property
    @pulumi.getter
    def retries(self) -> Optional['outputs.VirtualServiceSpecHttpRetries']:
        """
        Retry policy for HTTP requests.
        """
        return pulumi.get(self, "retries")

    @property
    @pulumi.getter
    def rewrite(self) -> Optional['outputs.VirtualServiceSpecHttpRewrite']:
        """
        Rewrite HTTP URIs and Authority headers.
        """
        return pulumi.get(self, "rewrite")

    @property
    @pulumi.getter
    def route(self) -> Optional[Sequence['outputs.VirtualServiceSpecHttpRoute']]:
        """
        A HTTP rule can either redirect or forward (default) traffic.
        """
        return pulumi.get(self, "route")

    @property
    @pulumi.getter
    def timeout(self) -> Optional[str]:
        """
        Timeout for HTTP requests, default is disabled.
        """
        return pulumi.get(self, "timeout")


@pulumi.output_type
class VirtualServiceSpecHttpCorsPolicy(dict):
    """
    Cross-Origin Resource Sharing policy (CORS).
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigin":
            suggest = "allow_origin"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualServiceSpecHttpCorsPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualServiceSpecHttpCorsPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualServiceSpecHttpCorsPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[bool] = None,
                 allow_headers: Optional[Sequence[str]] = None,
                 allow_methods: Optional[Sequence[str]] = None,
                 allow_origin: Optional[Sequence[str]] = None,
                 allow_origins: Optional[Sequence[Any]] = None,
                 expose_headers: Optional[Sequence[str]] = None,
                 max_age: Optional[str] = None):
        """
        Cross-Origin Resource Sharing policy (CORS).
        :param Sequence[str] allow_methods: List of HTTP methods allowed to access the resource.
        :param Sequence[str] allow_origin: The list of origins that are allowed to perform CORS requests.
        :param Sequence[Any] allow_origins: String patterns that match allowed origins.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origin is not None:
            pulumi.set(__self__, "allow_origin", allow_origin)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[bool]:
        return pulumi.get(self, "allow_credentials")

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "allow_headers")

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[str]]:
        """
        List of HTTP methods allowed to access the resource.
        """
        return pulumi.get(self, "allow_methods")

    @property
    @pulumi.getter(name="allowOrigin")
    def allow_origin(self) -> Optional[Sequence[str]]:
        """
        The list of origins that are allowed to perform CORS requests.
        """
        return pulumi.get(self, "allow_origin")

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[Sequence[Any]]:
        """
        String patterns that match allowed origins.
        """
        return pulumi.get(self, "allow_origins")

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "expose_headers")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[str]:
        return pulumi.get(self, "max_age")


@pulumi.output_type
class VirtualServiceSpecHttpDelegate(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 namespace: Optional[str] = None):
        """
        :param str name: Name specifies the name of the delegate VirtualService.
        :param str namespace: Namespace specifies the namespace where the delegate VirtualService resides.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name specifies the name of the delegate VirtualService.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace specifies the namespace where the delegate VirtualService resides.
        """
        return pulumi.get(self, "namespace")


@pulumi.output_type
class VirtualServiceSpecHttpFault(dict):
    """
    Fault injection policy to apply on HTTP traffic at the client side.
    """
    def __init__(__self__, *,
                 abort: Optional[Any] = None,
                 delay: Optional[Any] = None):
        """
        Fault injection policy to apply on HTTP traffic at the client side.
        """
        if abort is not None:
            pulumi.set(__self__, "abort", abort)
        if delay is not None:
            pulumi.set(__self__, "delay", delay)

    @property
    @pulumi.getter
    def abort(self) -> Optional[Any]:
        return pulumi.get(self, "abort")

    @property
    @pulumi.getter
    def delay(self) -> Optional[Any]:
        return pulumi.get(self, "delay")


@pulumi.output_type
class VirtualServiceSpecHttpHeaders(dict):
    def __init__(__self__, *,
                 request: Optional['outputs.VirtualServiceSpecHttpHeadersRequest'] = None,
                 response: Optional['outputs.VirtualServiceSpecHttpHeadersResponse'] = None):
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.VirtualServiceSpecHttpHeadersRequest']:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.VirtualServiceSpecHttpHeadersResponse']:
        return pulumi.get(self, "response")


@pulumi.output_type
class VirtualServiceSpecHttpHeadersRequest(dict):
    def __init__(__self__, *,
                 add: Optional[Mapping[str, str]] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Mapping[str, str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "set")


@pulumi.output_type
class VirtualServiceSpecHttpHeadersResponse(dict):
    def __init__(__self__, *,
                 add: Optional[Mapping[str, str]] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Mapping[str, str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "set")


@pulumi.output_type
class VirtualServiceSpecHttpMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreUriCase":
            suggest = "ignore_uri_case"
        elif key == "queryParams":
            suggest = "query_params"
        elif key == "sourceLabels":
            suggest = "source_labels"
        elif key == "sourceNamespace":
            suggest = "source_namespace"
        elif key == "withoutHeaders":
            suggest = "without_headers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualServiceSpecHttpMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualServiceSpecHttpMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualServiceSpecHttpMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority: Optional[Any] = None,
                 gateways: Optional[Sequence[str]] = None,
                 headers: Optional[Mapping[str, Any]] = None,
                 ignore_uri_case: Optional[bool] = None,
                 method: Optional[Any] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 query_params: Optional[Mapping[str, Any]] = None,
                 scheme: Optional[Any] = None,
                 source_labels: Optional[Mapping[str, str]] = None,
                 source_namespace: Optional[str] = None,
                 uri: Optional[Any] = None,
                 without_headers: Optional[Mapping[str, Any]] = None):
        """
        :param Sequence[str] gateways: Names of gateways where the rule should be applied.
        :param bool ignore_uri_case: Flag to specify whether the URI matching should be case-insensitive.
        :param str name: The name assigned to a match.
        :param int port: Specifies the ports on the host that is being addressed.
        :param Mapping[str, Any] query_params: Query parameters for matching.
        :param str source_namespace: Source namespace constraining the applicability of a rule to workloads in that namespace.
        :param Mapping[str, Any] without_headers: withoutHeader has the same syntax with the header, but has opposite meaning.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if ignore_uri_case is not None:
            pulumi.set(__self__, "ignore_uri_case", ignore_uri_case)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if query_params is not None:
            pulumi.set(__self__, "query_params", query_params)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if source_labels is not None:
            pulumi.set(__self__, "source_labels", source_labels)
        if source_namespace is not None:
            pulumi.set(__self__, "source_namespace", source_namespace)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)
        if without_headers is not None:
            pulumi.set(__self__, "without_headers", without_headers)

    @property
    @pulumi.getter
    def authority(self) -> Optional[Any]:
        return pulumi.get(self, "authority")

    @property
    @pulumi.getter
    def gateways(self) -> Optional[Sequence[str]]:
        """
        Names of gateways where the rule should be applied.
        """
        return pulumi.get(self, "gateways")

    @property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, Any]]:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter(name="ignoreUriCase")
    def ignore_uri_case(self) -> Optional[bool]:
        """
        Flag to specify whether the URI matching should be case-insensitive.
        """
        return pulumi.get(self, "ignore_uri_case")

    @property
    @pulumi.getter
    def method(self) -> Optional[Any]:
        return pulumi.get(self, "method")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        The name assigned to a match.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Specifies the ports on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="queryParams")
    def query_params(self) -> Optional[Mapping[str, Any]]:
        """
        Query parameters for matching.
        """
        return pulumi.get(self, "query_params")

    @property
    @pulumi.getter
    def scheme(self) -> Optional[Any]:
        return pulumi.get(self, "scheme")

    @property
    @pulumi.getter(name="sourceLabels")
    def source_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "source_labels")

    @property
    @pulumi.getter(name="sourceNamespace")
    def source_namespace(self) -> Optional[str]:
        """
        Source namespace constraining the applicability of a rule to workloads in that namespace.
        """
        return pulumi.get(self, "source_namespace")

    @property
    @pulumi.getter
    def uri(self) -> Optional[Any]:
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="withoutHeaders")
    def without_headers(self) -> Optional[Mapping[str, Any]]:
        """
        withoutHeader has the same syntax with the header, but has opposite meaning.
        """
        return pulumi.get(self, "without_headers")


@pulumi.output_type
class VirtualServiceSpecHttpMirror(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional['outputs.VirtualServiceSpecHttpMirrorPort'] = None,
                 subset: Optional[str] = None):
        """
        :param str host: The name of a service from the service registry.
        :param 'VirtualServiceSpecHttpMirrorPortArgs' port: Specifies the port on the host that is being addressed.
        :param str subset: The name of a subset within the service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subset is not None:
            pulumi.set(__self__, "subset", subset)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional['outputs.VirtualServiceSpecHttpMirrorPort']:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def subset(self) -> Optional[str]:
        """
        The name of a subset within the service.
        """
        return pulumi.get(self, "subset")


@pulumi.output_type
class VirtualServiceSpecHttpMirrorPercentage(dict):
    """
    Percentage of the traffic to be mirrored by the `mirror` field.
    """
    def __init__(__self__, *,
                 value: Optional[float] = None):
        """
        Percentage of the traffic to be mirrored by the `mirror` field.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[float]:
        return pulumi.get(self, "value")


@pulumi.output_type
class VirtualServiceSpecHttpMirrorPort(dict):
    """
    Specifies the port on the host that is being addressed.
    """
    def __init__(__self__, *,
                 number: Optional[int] = None):
        """
        Specifies the port on the host that is being addressed.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        return pulumi.get(self, "number")


@pulumi.output_type
class VirtualServiceSpecHttpRetries(dict):
    """
    Retry policy for HTTP requests.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "perTryTimeout":
            suggest = "per_try_timeout"
        elif key == "retryOn":
            suggest = "retry_on"
        elif key == "retryRemoteLocalities":
            suggest = "retry_remote_localities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualServiceSpecHttpRetries. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualServiceSpecHttpRetries.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualServiceSpecHttpRetries.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attempts: Optional[int] = None,
                 per_try_timeout: Optional[str] = None,
                 retry_on: Optional[str] = None,
                 retry_remote_localities: Optional[bool] = None):
        """
        Retry policy for HTTP requests.
        :param int attempts: Number of retries to be allowed for a given request.
        :param str per_try_timeout: Timeout per attempt for a given request, including the initial call and any retries.
        :param str retry_on: Specifies the conditions under which retry takes place.
        :param bool retry_remote_localities: Flag to specify whether the retries should retry to other localities.
        """
        if attempts is not None:
            pulumi.set(__self__, "attempts", attempts)
        if per_try_timeout is not None:
            pulumi.set(__self__, "per_try_timeout", per_try_timeout)
        if retry_on is not None:
            pulumi.set(__self__, "retry_on", retry_on)
        if retry_remote_localities is not None:
            pulumi.set(__self__, "retry_remote_localities", retry_remote_localities)

    @property
    @pulumi.getter
    def attempts(self) -> Optional[int]:
        """
        Number of retries to be allowed for a given request.
        """
        return pulumi.get(self, "attempts")

    @property
    @pulumi.getter(name="perTryTimeout")
    def per_try_timeout(self) -> Optional[str]:
        """
        Timeout per attempt for a given request, including the initial call and any retries.
        """
        return pulumi.get(self, "per_try_timeout")

    @property
    @pulumi.getter(name="retryOn")
    def retry_on(self) -> Optional[str]:
        """
        Specifies the conditions under which retry takes place.
        """
        return pulumi.get(self, "retry_on")

    @property
    @pulumi.getter(name="retryRemoteLocalities")
    def retry_remote_localities(self) -> Optional[bool]:
        """
        Flag to specify whether the retries should retry to other localities.
        """
        return pulumi.get(self, "retry_remote_localities")


@pulumi.output_type
class VirtualServiceSpecHttpRewrite(dict):
    """
    Rewrite HTTP URIs and Authority headers.
    """
    def __init__(__self__, *,
                 authority: Optional[str] = None,
                 uri: Optional[str] = None):
        """
        Rewrite HTTP URIs and Authority headers.
        :param str authority: rewrite the Authority/Host header with this value.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def authority(self) -> Optional[str]:
        """
        rewrite the Authority/Host header with this value.
        """
        return pulumi.get(self, "authority")

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        return pulumi.get(self, "uri")


@pulumi.output_type
class VirtualServiceSpecHttpRoute(dict):
    def __init__(__self__, *,
                 destination: Optional['outputs.VirtualServiceSpecHttpRouteDestination'] = None,
                 headers: Optional['outputs.VirtualServiceSpecHttpRouteHeaders'] = None,
                 weight: Optional[int] = None):
        """
        :param int weight: Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.VirtualServiceSpecHttpRouteDestination']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def headers(self) -> Optional['outputs.VirtualServiceSpecHttpRouteHeaders']:
        return pulumi.get(self, "headers")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class VirtualServiceSpecHttpRouteDestination(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional['outputs.VirtualServiceSpecHttpRouteDestinationPort'] = None,
                 subset: Optional[str] = None):
        """
        :param str host: The name of a service from the service registry.
        :param 'VirtualServiceSpecHttpRouteDestinationPortArgs' port: Specifies the port on the host that is being addressed.
        :param str subset: The name of a subset within the service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subset is not None:
            pulumi.set(__self__, "subset", subset)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional['outputs.VirtualServiceSpecHttpRouteDestinationPort']:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def subset(self) -> Optional[str]:
        """
        The name of a subset within the service.
        """
        return pulumi.get(self, "subset")


@pulumi.output_type
class VirtualServiceSpecHttpRouteDestinationPort(dict):
    """
    Specifies the port on the host that is being addressed.
    """
    def __init__(__self__, *,
                 number: Optional[int] = None):
        """
        Specifies the port on the host that is being addressed.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        return pulumi.get(self, "number")


@pulumi.output_type
class VirtualServiceSpecHttpRouteHeaders(dict):
    def __init__(__self__, *,
                 request: Optional['outputs.VirtualServiceSpecHttpRouteHeadersRequest'] = None,
                 response: Optional['outputs.VirtualServiceSpecHttpRouteHeadersResponse'] = None):
        if request is not None:
            pulumi.set(__self__, "request", request)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @property
    @pulumi.getter
    def request(self) -> Optional['outputs.VirtualServiceSpecHttpRouteHeadersRequest']:
        return pulumi.get(self, "request")

    @property
    @pulumi.getter
    def response(self) -> Optional['outputs.VirtualServiceSpecHttpRouteHeadersResponse']:
        return pulumi.get(self, "response")


@pulumi.output_type
class VirtualServiceSpecHttpRouteHeadersRequest(dict):
    def __init__(__self__, *,
                 add: Optional[Mapping[str, str]] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Mapping[str, str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "set")


@pulumi.output_type
class VirtualServiceSpecHttpRouteHeadersResponse(dict):
    def __init__(__self__, *,
                 add: Optional[Mapping[str, str]] = None,
                 remove: Optional[Sequence[str]] = None,
                 set: Optional[Mapping[str, str]] = None):
        if add is not None:
            pulumi.set(__self__, "add", add)
        if remove is not None:
            pulumi.set(__self__, "remove", remove)
        if set is not None:
            pulumi.set(__self__, "set", set)

    @property
    @pulumi.getter
    def add(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "add")

    @property
    @pulumi.getter
    def remove(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "remove")

    @property
    @pulumi.getter
    def set(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "set")


@pulumi.output_type
class VirtualServiceSpecTcp(dict):
    def __init__(__self__, *,
                 match: Optional[Sequence['outputs.VirtualServiceSpecTcpMatch']] = None,
                 route: Optional[Sequence['outputs.VirtualServiceSpecTcpRoute']] = None):
        """
        :param Sequence['VirtualServiceSpecTcpRouteArgs'] route: The destination to which the connection should be forwarded to.
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter
    def match(self) -> Optional[Sequence['outputs.VirtualServiceSpecTcpMatch']]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def route(self) -> Optional[Sequence['outputs.VirtualServiceSpecTcpRoute']]:
        """
        The destination to which the connection should be forwarded to.
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class VirtualServiceSpecTcpMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationSubnets":
            suggest = "destination_subnets"
        elif key == "sourceLabels":
            suggest = "source_labels"
        elif key == "sourceNamespace":
            suggest = "source_namespace"
        elif key == "sourceSubnet":
            suggest = "source_subnet"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualServiceSpecTcpMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualServiceSpecTcpMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualServiceSpecTcpMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_subnets: Optional[Sequence[str]] = None,
                 gateways: Optional[Sequence[str]] = None,
                 port: Optional[int] = None,
                 source_labels: Optional[Mapping[str, str]] = None,
                 source_namespace: Optional[str] = None,
                 source_subnet: Optional[str] = None):
        """
        :param Sequence[str] destination_subnets: IPv4 or IPv6 ip addresses of destination with optional subnet.
        :param Sequence[str] gateways: Names of gateways where the rule should be applied.
        :param int port: Specifies the port on the host that is being addressed.
        :param str source_namespace: Source namespace constraining the applicability of a rule to workloads in that namespace.
        :param str source_subnet: IPv4 or IPv6 ip address of source with optional subnet.
        """
        if destination_subnets is not None:
            pulumi.set(__self__, "destination_subnets", destination_subnets)
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if source_labels is not None:
            pulumi.set(__self__, "source_labels", source_labels)
        if source_namespace is not None:
            pulumi.set(__self__, "source_namespace", source_namespace)
        if source_subnet is not None:
            pulumi.set(__self__, "source_subnet", source_subnet)

    @property
    @pulumi.getter(name="destinationSubnets")
    def destination_subnets(self) -> Optional[Sequence[str]]:
        """
        IPv4 or IPv6 ip addresses of destination with optional subnet.
        """
        return pulumi.get(self, "destination_subnets")

    @property
    @pulumi.getter
    def gateways(self) -> Optional[Sequence[str]]:
        """
        Names of gateways where the rule should be applied.
        """
        return pulumi.get(self, "gateways")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sourceLabels")
    def source_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "source_labels")

    @property
    @pulumi.getter(name="sourceNamespace")
    def source_namespace(self) -> Optional[str]:
        """
        Source namespace constraining the applicability of a rule to workloads in that namespace.
        """
        return pulumi.get(self, "source_namespace")

    @property
    @pulumi.getter(name="sourceSubnet")
    def source_subnet(self) -> Optional[str]:
        """
        IPv4 or IPv6 ip address of source with optional subnet.
        """
        return pulumi.get(self, "source_subnet")


@pulumi.output_type
class VirtualServiceSpecTcpRoute(dict):
    def __init__(__self__, *,
                 destination: Optional['outputs.VirtualServiceSpecTcpRouteDestination'] = None,
                 weight: Optional[int] = None):
        """
        :param int weight: Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.VirtualServiceSpecTcpRouteDestination']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class VirtualServiceSpecTcpRouteDestination(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional['outputs.VirtualServiceSpecTcpRouteDestinationPort'] = None,
                 subset: Optional[str] = None):
        """
        :param str host: The name of a service from the service registry.
        :param 'VirtualServiceSpecTcpRouteDestinationPortArgs' port: Specifies the port on the host that is being addressed.
        :param str subset: The name of a subset within the service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subset is not None:
            pulumi.set(__self__, "subset", subset)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional['outputs.VirtualServiceSpecTcpRouteDestinationPort']:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def subset(self) -> Optional[str]:
        """
        The name of a subset within the service.
        """
        return pulumi.get(self, "subset")


@pulumi.output_type
class VirtualServiceSpecTcpRouteDestinationPort(dict):
    """
    Specifies the port on the host that is being addressed.
    """
    def __init__(__self__, *,
                 number: Optional[int] = None):
        """
        Specifies the port on the host that is being addressed.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        return pulumi.get(self, "number")


@pulumi.output_type
class VirtualServiceSpecTls(dict):
    def __init__(__self__, *,
                 match: Optional[Sequence['outputs.VirtualServiceSpecTlsMatch']] = None,
                 route: Optional[Sequence['outputs.VirtualServiceSpecTlsRoute']] = None):
        """
        :param Sequence['VirtualServiceSpecTlsRouteArgs'] route: The destination to which the connection should be forwarded to.
        """
        if match is not None:
            pulumi.set(__self__, "match", match)
        if route is not None:
            pulumi.set(__self__, "route", route)

    @property
    @pulumi.getter
    def match(self) -> Optional[Sequence['outputs.VirtualServiceSpecTlsMatch']]:
        return pulumi.get(self, "match")

    @property
    @pulumi.getter
    def route(self) -> Optional[Sequence['outputs.VirtualServiceSpecTlsRoute']]:
        """
        The destination to which the connection should be forwarded to.
        """
        return pulumi.get(self, "route")


@pulumi.output_type
class VirtualServiceSpecTlsMatch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationSubnets":
            suggest = "destination_subnets"
        elif key == "sniHosts":
            suggest = "sni_hosts"
        elif key == "sourceLabels":
            suggest = "source_labels"
        elif key == "sourceNamespace":
            suggest = "source_namespace"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VirtualServiceSpecTlsMatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VirtualServiceSpecTlsMatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VirtualServiceSpecTlsMatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_subnets: Optional[Sequence[str]] = None,
                 gateways: Optional[Sequence[str]] = None,
                 port: Optional[int] = None,
                 sni_hosts: Optional[Sequence[str]] = None,
                 source_labels: Optional[Mapping[str, str]] = None,
                 source_namespace: Optional[str] = None):
        """
        :param Sequence[str] destination_subnets: IPv4 or IPv6 ip addresses of destination with optional subnet.
        :param Sequence[str] gateways: Names of gateways where the rule should be applied.
        :param int port: Specifies the port on the host that is being addressed.
        :param Sequence[str] sni_hosts: SNI (server name indicator) to match on.
        :param str source_namespace: Source namespace constraining the applicability of a rule to workloads in that namespace.
        """
        if destination_subnets is not None:
            pulumi.set(__self__, "destination_subnets", destination_subnets)
        if gateways is not None:
            pulumi.set(__self__, "gateways", gateways)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if sni_hosts is not None:
            pulumi.set(__self__, "sni_hosts", sni_hosts)
        if source_labels is not None:
            pulumi.set(__self__, "source_labels", source_labels)
        if source_namespace is not None:
            pulumi.set(__self__, "source_namespace", source_namespace)

    @property
    @pulumi.getter(name="destinationSubnets")
    def destination_subnets(self) -> Optional[Sequence[str]]:
        """
        IPv4 or IPv6 ip addresses of destination with optional subnet.
        """
        return pulumi.get(self, "destination_subnets")

    @property
    @pulumi.getter
    def gateways(self) -> Optional[Sequence[str]]:
        """
        Names of gateways where the rule should be applied.
        """
        return pulumi.get(self, "gateways")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sniHosts")
    def sni_hosts(self) -> Optional[Sequence[str]]:
        """
        SNI (server name indicator) to match on.
        """
        return pulumi.get(self, "sni_hosts")

    @property
    @pulumi.getter(name="sourceLabels")
    def source_labels(self) -> Optional[Mapping[str, str]]:
        return pulumi.get(self, "source_labels")

    @property
    @pulumi.getter(name="sourceNamespace")
    def source_namespace(self) -> Optional[str]:
        """
        Source namespace constraining the applicability of a rule to workloads in that namespace.
        """
        return pulumi.get(self, "source_namespace")


@pulumi.output_type
class VirtualServiceSpecTlsRoute(dict):
    def __init__(__self__, *,
                 destination: Optional['outputs.VirtualServiceSpecTlsRouteDestination'] = None,
                 weight: Optional[int] = None):
        """
        :param int weight: Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def destination(self) -> Optional['outputs.VirtualServiceSpecTlsRouteDestination']:
        return pulumi.get(self, "destination")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight specifies the relative proportion of traffic to be forwarded to the destination.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class VirtualServiceSpecTlsRouteDestination(dict):
    def __init__(__self__, *,
                 host: Optional[str] = None,
                 port: Optional['outputs.VirtualServiceSpecTlsRouteDestinationPort'] = None,
                 subset: Optional[str] = None):
        """
        :param str host: The name of a service from the service registry.
        :param 'VirtualServiceSpecTlsRouteDestinationPortArgs' port: Specifies the port on the host that is being addressed.
        :param str subset: The name of a subset within the service.
        """
        if host is not None:
            pulumi.set(__self__, "host", host)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if subset is not None:
            pulumi.set(__self__, "subset", subset)

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        The name of a service from the service registry.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def port(self) -> Optional['outputs.VirtualServiceSpecTlsRouteDestinationPort']:
        """
        Specifies the port on the host that is being addressed.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def subset(self) -> Optional[str]:
        """
        The name of a subset within the service.
        """
        return pulumi.get(self, "subset")


@pulumi.output_type
class VirtualServiceSpecTlsRouteDestinationPort(dict):
    """
    Specifies the port on the host that is being addressed.
    """
    def __init__(__self__, *,
                 number: Optional[int] = None):
        """
        Specifies the port on the host that is being addressed.
        """
        if number is not None:
            pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> Optional[int]:
        return pulumi.get(self, "number")


@pulumi.output_type
class WorkloadEntrySpec(dict):
    """
    Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WorkloadEntrySpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WorkloadEntrySpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WorkloadEntrySpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 locality: Optional[str] = None,
                 network: Optional[str] = None,
                 ports: Optional[Mapping[str, int]] = None,
                 service_account: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        Configuration affecting VMs onboarded into the mesh. See more details at: https://istio.io/docs/reference/config/networking/workload-entry.html
        :param Mapping[str, str] labels: One or more labels associated with the endpoint.
        :param str locality: The locality associated with the endpoint.
        :param Mapping[str, int] ports: Set of ports associated with the endpoint.
        :param int weight: The load balancing weight associated with the endpoint.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        One or more labels associated with the endpoint.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter
    def locality(self) -> Optional[str]:
        """
        The locality associated with the endpoint.
        """
        return pulumi.get(self, "locality")

    @property
    @pulumi.getter
    def network(self) -> Optional[str]:
        return pulumi.get(self, "network")

    @property
    @pulumi.getter
    def ports(self) -> Optional[Mapping[str, int]]:
        """
        Set of ports associated with the endpoint.
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[str]:
        return pulumi.get(self, "service_account")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        The load balancing weight associated with the endpoint.
        """
        return pulumi.get(self, "weight")


